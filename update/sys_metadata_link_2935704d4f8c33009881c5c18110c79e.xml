<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_metadata_link">
    <sys_metadata_link action="INSERT_OR_UPDATE">
        <directory>update</directory>
        <documentkey>50aeb3474fd3134035e0fdb28110c799</documentkey>
        <payload><![CDATA[<?xml version="1.0" encoding="UTF-8"?><record_update table="x_snc_cozmo_guard_python_commands">
    <x_snc_cozmo_guard_python_commands action="INSERT_OR_UPDATE">
        <active>false</active>
        <file_name>unleash.py</file_name>
        <name>unleash</name>
        <script>#!/usr/bin/env python3&#13;
&#13;
#import required functions&#13;
import sys, os, datetime, random, time, math, re, threading&#13;
import asyncio, cozmo, cozmo.objects, cozmo.util&#13;
from cozmo.util import degrees, distance_mm, speed_mmps, Pose&#13;
from cozmo.objects import CustomObject, CustomObjectMarkers, CustomObjectTypes&#13;
&#13;
# set up global variables&#13;
global robot&#13;
global freeplay&#13;
global needslevel&#13;
global cozmostate&#13;
global scheduler_playokay&#13;
global msg&#13;
global start_time&#13;
global use_cubes&#13;
global charger&#13;
global lowbatvoltage&#13;
global use_scheduler&#13;
# initialize needed variables&#13;
freeplay=0&#13;
robot = cozmo.robot.Robot&#13;
msg = 'No status'&#13;
q = None # dependency on queue variable for messaging instead of printing to event-content directly&#13;
thread_running = False # starting thread for custom events&#13;
&#13;
# CONFIGURABLE VARIABLES HERE&#13;
#&#13;
# low battery voltage - when voltage drops below this Cozmo will start looking for his charger&#13;
lowbatvoltage = 3.7&#13;
# whether or not to activate the cubes (saves battery if you don't)&#13;
use_cubes = 0&#13;
#&#13;
# whether or not to use the schedule to define allowed "play times"&#13;
use_scheduler = 0&#13;
# &#13;
# END OF CONFIGURABLE VARIABLES&#13;
#&#13;
&#13;
#&#13;
# MAIN PROGRAM LOOP START&#13;
#&#13;
def cozmo_unleashed(robot: cozmo.robot.Robot):&#13;
	global cozmostate,freeplay,start_time,needslevel,scheduler_playokay,use_cubes, charger, lowbatvoltage, use_scheduler,msg&#13;
	robot.world.charger = None&#13;
	charger = None&#13;
	robot.set_robot_volume(0.2)&#13;
	# set up some camera stuff&#13;
	camera = robot.camera&#13;
	camera.enable_auto_exposure()&#13;
	robot.enable_facial_expression_estimation(enable=True)&#13;
	if use_cubes == 0:&#13;
		robot.world.disconnect_from_cubes()&#13;
	robot.enable_all_reaction_triggers(False)&#13;
	robot.enable_stop_on_cliff(True)&#13;
	q = None # dependency on queue variable for messaging instead of printing to event-content directly&#13;
	thread_running = False # starting thread for custom events&#13;
	robot.set_needs_levels(repair_value=1, energy_value=1, play_value=1)&#13;
	needslevel = 1&#13;
	lowbatcount=0&#13;
	cozmostate=0&#13;
	#some custom objects that I printed out and use as walls, if you don't have them don't worry about it, it won't affect the program&#13;
	wall_obj1 = robot.world.define_custom_wall(CustomObjectTypes.CustomType01, CustomObjectMarkers.Circles2,  340, 120, 44, 44, True)&#13;
	wall_obj2 = robot.world.define_custom_wall(CustomObjectTypes.CustomType02, CustomObjectMarkers.Circles4,  340, 120, 44, 44, True)&#13;
	wall_obj3 = robot.world.define_custom_wall(CustomObjectTypes.CustomType03, CustomObjectMarkers.Circles5,  340, 120, 44, 44, True)&#13;
	wall_obj4 = robot.world.define_custom_wall(CustomObjectTypes.CustomType04, CustomObjectMarkers.Triangles2,340, 120, 44, 44, True)&#13;
	wall_obj5 = robot.world.define_custom_wall(CustomObjectTypes.CustomType05, CustomObjectMarkers.Triangles3,340, 120, 44, 44, True)&#13;
	wall_obj6 = robot.world.define_custom_wall(CustomObjectTypes.CustomType06, CustomObjectMarkers.Hexagons2, 120, 340, 44, 44, True)&#13;
	wall_obj7 = robot.world.define_custom_wall(CustomObjectTypes.CustomType07, CustomObjectMarkers.Circles3,  120, 340, 44, 44, True)&#13;
	wall_obj8 = robot.world.define_custom_wall(CustomObjectTypes.CustomType08, CustomObjectMarkers.Hexagons3, 120, 340, 44, 44, True)&#13;
&#13;
	# initialize event monitoring thread&#13;
	q = None&#13;
	monitor(robot, q)&#13;
	start_time = time.time()&#13;
&#13;
# ENTERING STATE LOOP&#13;
	while True:&#13;
#&#13;
#State 1: on charger, charging&#13;
#&#13;
		if (robot.is_on_charger == 1) and (robot.is_charging == 1):&#13;
			if cozmostate != 1: # 1 is charging&#13;
				start_time = time.time()&#13;
				robot_set_backpacklights(65535)  # 65535 is blue&#13;
				cozmostate = 1&#13;
				time.sleep(1)&#13;
			robot_set_needslevel()&#13;
			if use_cubes == 1:&#13;
				robot.world.disconnect_from_cubes()&#13;
			lowbatcount=0&#13;
			robot_print_current_state('charging')&#13;
			# once in a while make random snoring noises&#13;
			robot_check_sleep_snoring()&#13;
#&#13;
#State 2: on charger, fully charged&#13;
#&#13;
		if (robot.is_on_charger == 1) and (robot.is_charging == 0):&#13;
			if cozmostate != 2:  # 2 is fully charged&#13;
				cozmostate = 2&#13;
				lowbatcount=0&#13;
				robot_set_backpacklights(16711935)  # 16711935 is green&#13;
				robot.set_needs_levels(repair_value=1, energy_value=1, play_value=1)&#13;
			robot_set_needslevel()&#13;
			robot_check_scheduler()&#13;
#&#13;
#State 3: not on charger, battery starting to get low&#13;
#&#13;
		# basic 'trigger guard' so Cozmo doesn't go to charger immediately if the voltage happens to dip below 3.7&#13;
		if (robot.battery_voltage &lt;= lowbatvoltage) and (robot.is_on_charger == 0) and cozmostate != 5 and cozmostate != 6:&#13;
			lowbatcount += 1&#13;
			robot_set_needslevel()&#13;
			robot_print_current_state('battery getting low')&#13;
			robot_reaction_chance(cozmo.anim.Triggers.CodeLabTakaTaka,1,False,False,False)&#13;
			time.sleep(1)&#13;
		&#13;
		if lowbatcount &gt; 2 and (robot.is_on_charger == 0):&#13;
			if cozmostate != 3: # 3 is looking for dock&#13;
				cozmostate = 3&#13;
				if use_cubes == 1:&#13;
					robot.world.disconnect_from_cubes()&#13;
			robot_set_needslevel()&#13;
			robot_set_backpacklights(4278190335)  # 4278190335 is red&#13;
			cozmostate = 5&#13;
#			&#13;
#State 4: not on charger, good battery&#13;
#&#13;
		if (robot.battery_voltage &gt; lowbatvoltage) and (robot.is_on_charger == 0) and cozmostate != 9 and cozmostate != 5 and cozmostate != 6 and cozmostate != 3:&#13;
			if cozmostate != 4: # 4 is freeplay&#13;
				cozmostate = 4&#13;
				#initiate freeplay&#13;
				if freeplay==0:&#13;
					start_time = time.time()&#13;
					robot_set_backpacklights(16711935)  # 16711935 is green&#13;
					try:&#13;
						robot.drive_wheels(40, 40, l_wheel_acc=50, r_wheel_acc=50, duration=1)&#13;
					except:&#13;
						pass&#13;
					robot_reaction_chance(cozmo.anim.Triggers.OnSpeedtapGameCozmoWinHighIntensity,1,True,True,False)&#13;
					robot_print_current_state('entering freeplay state')&#13;
					if use_cubes == 1:&#13;
						robot.world.connect_to_cubes()&#13;
					robot.enable_all_reaction_triggers(True)&#13;
					robot.start_freeplay_behaviors()&#13;
					freeplay=1&#13;
		#if use_cubes == 1:&#13;
		#	robot.world.connect_to_cubes()&#13;
			robot.enable_all_reaction_triggers(True)&#13;
			robot.start_freeplay_behaviors()&#13;
			freeplay=1&#13;
			robot_print_current_state('freeplay')&#13;
			robot_set_needslevel()&#13;
			robot_check_randomreaction()&#13;
			time.sleep(1)&#13;
#&#13;
# state 5: battery low, looking for charger&#13;
#&#13;
		if cozmostate == 5:&#13;
			robot.enable_all_reaction_triggers(False)&#13;
			robot.stop_freeplay_behaviors()&#13;
			while cozmostate == 5:&#13;
				robot_print_current_state('looking for charger main state')&#13;
				robot_set_needslevel()&#13;
				freeplay=0&#13;
				robot_locate_dock()&#13;
#&#13;
# state 6: battery low and we know where the charger is, moving to dock&#13;
#&#13;
		if cozmostate == 6:&#13;
			robot.enable_all_reaction_triggers(False)&#13;
			robot.stop_freeplay_behaviors()&#13;
			while cozmostate == 6:&#13;
				robot_print_current_state('charger found')&#13;
				robot_set_needslevel()&#13;
				robot_start_docking()						&#13;
#&#13;
# state 9: we're on our side or are currently picked up&#13;
#&#13;
		if cozmostate == 9:&#13;
			robot_print_current_state('picked up or on side')&#13;
			robot_set_needslevel()&#13;
#			&#13;
# we have looped through the states&#13;
#&#13;
		robot_set_needslevel()&#13;
		#robot_reaction_chance(cozmo.anim.Triggers.CodeLabChatty,98,True,True,False)&#13;
		#robot_print_current_state('cozmo_unleashed state program loop complete')&#13;
		time.sleep(1)&#13;
#&#13;
# end of loop&#13;
	robot_set_needslevel()&#13;
	robot_reaction_chance(cozmo.anim.Triggers.CodeLabTakaTaka,1,True,True,False)&#13;
	robot_reaction_chance(cozmo.anim.Triggers.CodeLabTakaTaka,1,True,True,False)&#13;
	robot_reaction_chance(cozmo.anim.Triggers.CodeLabTakaTaka,1,True,True,False)&#13;
	robot_print_current_state('exiting main loop - how did we get here?')&#13;
#&#13;
# END OF MAIN PROGRAM LOOP&#13;
#&#13;
# ROBOT FUNCTIONS&#13;
#&#13;
def robot_set_backpacklights(color):&#13;
	global robot&#13;
	color1=cozmo.lights.Color(int_color=color, rgb=None, name=None)&#13;
	color2=cozmo.lights.Color(int_color=0, rgb=None, name=None)&#13;
	light1=cozmo.lights.Light(on_color=color1, off_color=color2, on_period_ms=2000, off_period_ms=1000, transition_on_period_ms=1500, transition_off_period_ms=500)&#13;
	light2=cozmo.lights.Light(on_color=color1, off_color=color2, on_period_ms=1000, off_period_ms=1000, transition_on_period_ms=1000, transition_off_period_ms=2000)&#13;
	light3=cozmo.lights.Light(on_color=color1, off_color=color2, on_period_ms=1000, off_period_ms=2000, transition_on_period_ms=500, transition_off_period_ms=1500)&#13;
	robot.set_backpack_lights(None, light1, light2, light3, None)&#13;
&#13;
def robot_set_needslevel():&#13;
	global robot, needslevel, msg&#13;
	needslevel = 1 - (4.05 - robot.battery_voltage)&#13;
	if needslevel &lt; 0.1:&#13;
		needslevel = 0.1&#13;
	if needslevel &gt; 1:&#13;
		needslevel = 1&#13;
	robot.set_needs_levels(repair_value=needslevel, energy_value=needslevel, play_value=needslevel)&#13;
&#13;
def robot_check_sleep_snoring():&#13;
	global robot&#13;
	i = random.randint(1, 100)&#13;
	if i &gt;= 99:&#13;
		msg='state change: playing big snore'&#13;
		try:&#13;
			robot.play_anim("anim_guarddog_fakeout_02").wait_for_completed()&#13;
		except:&#13;
			pass&#13;
		try:&#13;
			robot.play_anim("anim_gotosleep_sleeploop_01").wait_for_completed()&#13;
		except:&#13;
			pass&#13;
	elif i &gt;= 90:&#13;
			msg='state change: playing small snore'&#13;
			try:&#13;
				robot.play_anim("anim_gotosleep_sleeploop_01").wait_for_completed()&#13;
			except:&#13;
				pass&#13;
	else:&#13;
		time.sleep(2)&#13;
&#13;
def robot_check_randomreaction():&#13;
	global robot,cozmostate,freeplay&#13;
	i = random.randint(1, 100)&#13;
	if i &gt;= 99 and not robot.is_carrying_block and not robot.is_picking_or_placing and not robot.is_pathing and cozmostate==4:&#13;
		#random action!&#13;
		robot.abort_all_actions(log_abort_messages=False)&#13;
		robot.enable_all_reaction_triggers(False)&#13;
		robot.stop_freeplay_behaviors()&#13;
		robot.abort_all_actions(log_abort_messages=False)&#13;
		robot.wait_for_all_actions_completed()&#13;
		# grab a list of animation triggers&#13;
		all_animation_triggers = robot.anim_triggers&#13;
		# randomly shuffle the animations&#13;
		random.shuffle(all_animation_triggers)&#13;
		# select the first three animations from the shuffled list&#13;
		triggers = 1&#13;
		chosen_triggers = all_animation_triggers[:triggers]&#13;
		print('Playing {} random animations:'.format(triggers))&#13;
		for trigger in chosen_triggers:&#13;
			print('Playing {}'.format(trigger.name))&#13;
			robot.play_anim_trigger(trigger).wait_for_completed()&#13;
		robot.wait_for_all_actions_completed()	&#13;
		if freeplay == 1:&#13;
			robot.enable_all_reaction_triggers(True)&#13;
			robot.start_freeplay_behaviors()&#13;
		time.sleep(1)&#13;
&#13;
def robot_check_scheduler():&#13;
	global robot,scheduler_playokay,use_cubes,use_scheduler&#13;
	# from 7pm on weekdays&#13;
	weekdaystartplay = 19&#13;
	# to 11pm on weekdays&#13;
	weekdaystopplay  = 23&#13;
	# from 7am on weekends&#13;
	weekendstartplay = 7&#13;
	# to 11pm on weekends&#13;
	weekendstopplay  = 23&#13;
	# scheduler - when battery is charged this represents the chance cozmo will get off his charger to play&#13;
	# chance is defined as a number between 1-99 with a higher number representing a lesser chance&#13;
	playchance = 1&#13;
	# day and time check - are we okay to play at this time and day?&#13;
	day_of_week = datetime.date.today().weekday() # 0 is Monday, 6 is Sunday&#13;
	ctime = datetime.datetime.now().time()&#13;
	scheduler_playokay=0&#13;
	#it's weekend! Check for allowed times.&#13;
	if day_of_week &gt; 4:&#13;
		if (ctime &gt; datetime.time(weekendstartplay) and ctime &lt; datetime.time(weekendstopplay)):&#13;
			scheduler_playokay=1&#13;
	#it's a weekday! Check for allowed times.&#13;
	else:&#13;
		if (ctime &gt; datetime.time(weekdaystartplay) and ctime &lt; datetime.time(weekdaystopplay)):&#13;
			scheduler_playokay=1&#13;
	# are we using the scheduler?&#13;
	if use_scheduler==0:&#13;
		scheduler_playokay=1&#13;
	# if the schedule says OK roll dice to see if we wake up&#13;
	if scheduler_playokay==1:&#13;
		i = random.randint(1, 100)&#13;
		# wake up chance&#13;
		if use_scheduler==0:&#13;
			i = 100&#13;
		if i &gt;= playchance:&#13;
			robot_print_current_state('leaving charger')&#13;
			#robot.world.connect_to_cubes()&#13;
			robot_set_backpacklights(16711935)  # 16711935 is green&#13;
			try:&#13;
				robot.play_anim("anim_gotosleep_getout_02").wait_for_completed()&#13;
			except:&#13;
				pass&#13;
			for _ in range(3):&#13;
				robot.drive_off_charger_contacts().wait_for_completed()&#13;
			time.sleep(2)&#13;
			robot.move_lift(-3)&#13;
			try:&#13;
				robot.drive_straight(distance_mm(60), speed_mmps(50)).wait_for_completed()&#13;
			except:&#13;
				pass&#13;
			try:&#13;
				robot.drive_straight(distance_mm(100), speed_mmps(50)).wait_for_completed()&#13;
			except:&#13;
				pass&#13;
	# we're out of schedule or didn't make the dice roll, back off and check again later.&#13;
	x = 1&#13;
	while x &lt; 20 and (robot.is_on_charger == 1):&#13;
		if scheduler_playokay == 1:&#13;
			print("State:  charged, schedule OK but not active, sleep loop %d of 30 before next check." % (x))&#13;
			time.sleep(1)&#13;
		else:&#13;
			print("State:  charged,  not active by schedule, sleep loop %d of 30 before next check." % (x))&#13;
			time.sleep(1)&#13;
			robot_check_sleep_snoring()&#13;
		if (robot.is_on_charger == 0):&#13;
			robot_print_current_state('cozmo was removed from charger')&#13;
			break&#13;
		time.sleep(5)&#13;
&#13;
def robot_print_current_state(currentstate):&#13;
	global robot,needslevel,start_time,cozmostate,msg&#13;
	robot_set_needslevel()&#13;
	os.system('cls' if os.name == 'nt' else 'clear')&#13;
	print("State: %s" %currentstate,"battery %s" % str(round(robot.battery_voltage, 2))," energy %s" % round(needslevel, 2)," runtime %s" % round(((time.time() - start_time)/60),2)," internal state %s"% cozmostate," last message: %s" %msg)&#13;
&#13;
def robot_reaction_chance(animation,chance,ignorebody,ignorehead,ignorelift):&#13;
	global robot&#13;
	i = random.randint(1, 100)&#13;
	if i &gt;= chance:&#13;
		robot.abort_all_actions(log_abort_messages=False)&#13;
		#robot.wait_for_all_actions_completed()&#13;
		try:&#13;
			robot.play_anim_trigger(animation, ignore_body_track=ignorebody, ignore_head_track=ignorehead, ignore_lift_track=ignorelift).wait_for_completed()&#13;
			print("state change: reaction %s" %str(animation)," executed")&#13;
		except:&#13;
			print("state change: reaction %s" %str(animation)," aborted")&#13;
		#robot.wait_for_all_actions_completed()&#13;
		try:&#13;
			robot.set_head_angle(degrees(0)).wait_for_completed()&#13;
		except:&#13;
			pass&#13;
		#robot.wait_for_all_actions_completed()&#13;
		try:&#13;
			robot.move_lift(-3)&#13;
		except:&#13;
			pass&#13;
	else:&#13;
		time.sleep(0.5)&#13;
&#13;
def robot_locate_dock():&#13;
	global robot,freeplay,use_cubes,charger,cozmostate&#13;
	#back off from whatever we were doing&#13;
	if freeplay==1:&#13;
		#robot_set_backpacklights(4278190335)  # 4278190335 is red&#13;
		robot.abort_all_actions(log_abort_messages=False)&#13;
		#robot.wait_for_all_actions_completed()&#13;
		robot.stop_freeplay_behaviors()&#13;
		robot.enable_all_reaction_triggers(False)&#13;
		if use_cubes==1:&#13;
			robot.world.disconnect_from_cubes()&#13;
		freeplay=0&#13;
		robot_reaction_chance(cozmo.anim.Triggers.NeedsMildLowEnergyRequest,1,False,False,False)&#13;
		try:&#13;
			robot.drive_straight(distance_mm(-30), speed_mmps(50)).wait_for_completed()&#13;
		except:&#13;
			pass&#13;
	robot_set_needslevel()&#13;
	robot_print_current_state('finding charger')&#13;
	# charger location search&#13;
	charger = None&#13;
	# see if we already know where the charger is&#13;
	if robot.world.charger:&#13;
		if robot.world.charger.pose.is_comparable(robot.pose):&#13;
			charger = robot.world.charger&#13;
			#we know where the charger is&#13;
			robot_print_current_state('finding charger, charger position known')&#13;
			robot_reaction_chance(cozmo.anim.Triggers.CodeLabSurprise,1,True,False,False)&#13;
			time.sleep(1)&#13;
			cozmostate=6&#13;
		else:&#13;
			robot_print_current_state('finding charger, charger not in expected location')&#13;
			charger = None&#13;
			robot.world.charger = None&#13;
			pass&#13;
	if not charger:&#13;
		robot_print_current_state('looking for charger')&#13;
		robot_reaction_chance(cozmo.anim.Triggers.SparkIdle,30,True,True,True)&#13;
		try:&#13;
			robot.move_lift(-3)&#13;
		except:&#13;
			pass&#13;
		try:&#13;
			robot.set_head_angle(degrees(0)).wait_for_completed()&#13;
		except:&#13;
			pass&#13;
		try:&#13;
			robot.drive_straight(distance_mm(-20), speed_mmps(50)).wait_for_completed()&#13;
		except:&#13;
			pass&#13;
		# randomly drive around for a bit and see if we can spot the charger&#13;
		robot_drive_random_pattern()&#13;
		robot_print_current_state('looking for charger, random drive loop complete')&#13;
		time.sleep(1)&#13;
&#13;
def robot_start_docking():&#13;
	global robot,needslevel,cozmostate,charger,freeplay&#13;
	charger = robot.world.charger&#13;
	try:&#13;
		action = robot.go_to_object(charger, distance_mm(65.0))&#13;
		action.wait_for_completed()&#13;
	except:&#13;
		try:&#13;
			action = robot.go_to_pose(robot.world.charger.pose)&#13;
			action.wait_for_completed()&#13;
		except:&#13;
			cozmostate = 5&#13;
	dockloop = 0&#13;
	while dockloop &lt; 2 and cozmostate ==6:&#13;
		#action = robot.go_to_pose(robot.world.charger.pose)&#13;
		#action.wait_for_completed()&#13;
		# get a little distance and have a look&#13;
		try:&#13;
			robot.drive_straight(distance_mm(-50), speed_mmps(50)).wait_for_completed()&#13;
		except:&#13;
			pass&#13;
		robot.set_head_light(False)&#13;
		if not robot.world.charger:&#13;
			# we can't see it. Remove charger from navigation map and quit this loop.&#13;
			robot.world.charger = None&#13;
			charger = None&#13;
			robot.play_anim_trigger(cozmo.anim.Triggers.ReactToPokeReaction, ignore_body_track=True, ignore_head_track=True, ignore_lift_track=True).wait_for_completed()&#13;
			#os.system('cls' if os.name == 'nt' else 'clear')&#13;
			print("State:  charger not found, clearing map. battery %s" % str(round(robot.battery_voltage, 2))," energy %s" % round(needslevel, 2)," runtime %s" % round(((time.time() - start_time)/60),2))&#13;
			break&#13;
		action = robot.go_to_pose(charger.pose)&#13;
		action.wait_for_completed()&#13;
		try:&#13;
			robot.drive_straight(distance_mm(-20), speed_mmps(50)).wait_for_completed()&#13;
		except:&#13;
			pass&#13;
		robot_reaction_chance(cozmo.anim.Triggers.FeedingReactToShake_Normal,85,True,False,False)&#13;
		robot_print_current_state('docking')&#13;
		robot.turn_in_place(degrees(95)).wait_for_completed()&#13;
		robot.turn_in_place(degrees(95)).wait_for_completed()&#13;
		time.sleep( 1 )&#13;
		robot_reaction_chance(cozmo.anim.Triggers.CubePounceFake,1,True,False,False)&#13;
		robot.drive_straight(distance_mm(-145), speed_mmps(150)).wait_for_completed()&#13;
		time.sleep( 1 )&#13;
		# check if we're now docked&#13;
		if robot.is_on_charger:&#13;
			# Yes! we're docked!&#13;
			cozmostate = 1&#13;
			robot_set_backpacklights(65535) # blue&#13;
			robot.play_anim("anim_sparking_success_02").wait_for_completed()&#13;
			try:&#13;
				robot.set_head_angle(degrees(0)).wait_for_completed()&#13;
			except:&#13;
				pass&#13;
			robot_print_current_state('docked')&#13;
			robot.play_anim("anim_gotosleep_getin_01").wait_for_completed()&#13;
			robot.play_anim("anim_gotosleep_sleeping_01").wait_for_completed()&#13;
			dockloop = 3&#13;
			break&#13;
		# No, we missed. Back off and try again&#13;
		else:&#13;
			robot_print_current_state('failed to dock')&#13;
			robot_reaction_chance(cozmo.anim.Triggers.AskToBeRightedRight,1,True,False,False)&#13;
			try:&#13;
				robot.move_lift(-3)&#13;
			except:&#13;
				pass&#13;
			try:&#13;
				robot.set_head_angle(degrees(0)).wait_for_completed()&#13;
			except:&#13;
				pass&#13;
			#os.system('cls' if os.name == 'nt' else 'clear')&#13;
			robot_print_current_state('failed to dock, retrying')&#13;
			try:&#13;
				robot.drive_straight(distance_mm(50), speed_mmps(50)).wait_for_completed()&#13;
			except:&#13;
				pass&#13;
			try:&#13;
				robot.turn_in_place(degrees(-3)).wait_for_completed()&#13;
			except:&#13;
				pass&#13;
			try:&#13;
				robot.drive_straight(distance_mm(100), speed_mmps(50)).wait_for_completed()&#13;
			except:&#13;
				pass&#13;
			try:&#13;
				robot.turn_in_place(degrees(94)).wait_for_completed()&#13;
			except:&#13;
				pass&#13;
			try:&#13;
				robot.turn_in_place(degrees(95)).wait_for_completed()&#13;
			except:&#13;
				pass&#13;
			try:&#13;
				robot.set_head_angle(degrees(0)).wait_for_completed()&#13;
			except:&#13;
				pass&#13;
			charger=None&#13;
			robot.world.charger=None&#13;
			time.sleep( 1 )&#13;
			dockloop+=1&#13;
	# express frustration&#13;
	try:&#13;
		robot.drive_straight(distance_mm(50), speed_mmps(50)).wait_for_completed()&#13;
	except:&#13;
		pass&#13;
	try:&#13;
		robot.turn_in_place(degrees(-3)).wait_for_completed()&#13;
	except:&#13;
		pass&#13;
	try:&#13;
		robot.drive_straight(distance_mm(80), speed_mmps(50)).wait_for_completed()&#13;
	except:&#13;
		pass&#13;
	robot_drive_random_pattern()&#13;
	robot_reaction_chance(cozmo.anim.Triggers.MemoryMatchPlayerWinGame,1,True,False,False)&#13;
	x=0&#13;
	while x&lt;11 and cozmostate == 5:&#13;
		if freeplay==0:&#13;
			freeplay = 1&#13;
			robot_set_backpacklights(16711935) # green&#13;
			if use_cubes==1:&#13;
				robot.world.connect_to_cubes()&#13;
			robot.enable_all_reaction_triggers(True)&#13;
			robot.start_freeplay_behaviors()&#13;
			cozmostate=4&#13;
		time.sleep(1)&#13;
		print("State:  charger not found, falling back to freeplay for a bit, loop %d of 10." % x)&#13;
		time.sleep(1)&#13;
		&#13;
		if robot.world.charger:&#13;
			robot_print_current_state('found charger while in temporary freeplay')&#13;
			charger = robot.world.charger&#13;
			cozmostate=6&#13;
			break&#13;
		x+=1&#13;
		time.sleep(1)&#13;
		#after 100 seconds or spotting the charger end freeplay&#13;
		robot.enable_all_reaction_triggers(False)&#13;
		robot.stop_freeplay_behaviors()&#13;
		if use_cubes==1:&#13;
			robot.world.disconnect_from_cubes()&#13;
		robot_set_backpacklights(4278190335) # red&#13;
		freeplay=0&#13;
		cozmostate = 5&#13;
		#os.system('cls' if os.name == 'nt' else 'clear')&#13;
		robot_print_current_state('stepping out of charger finding loop')&#13;
		time.sleep(1)&#13;
						&#13;
def robot_drive_random_pattern():&#13;
	global robot,use_cubes, charger, cozmostate&#13;
	loops=5&#13;
	while loops&gt;0 and cozmostate == 5:&#13;
		if robot.world.charger and robot.world.charger.pose.is_comparable(robot.pose):&#13;
			loops=0&#13;
			charger = robot.world.charger&#13;
			robot_reaction_chance(cozmo.anim.Triggers.CodeLabSurprise,1,True,True,True)&#13;
			robot_print_current_state('found charger breaking')&#13;
			cozmostate = 6&#13;
			break&#13;
		# drive to a random point and orientation&#13;
		counter=0&#13;
		while counter &lt; 2 and cozmostate ==5:&#13;
			if random.choice((True, False)):&#13;
				x=100&#13;
			else:&#13;
				x=-100&#13;
			if random.choice((True, False)):&#13;
				y=100&#13;
			else:&#13;
				y=-100&#13;
			z= random.randrange(-60, 61, 1)&#13;
			robot_print_current_state('looking for charger, going to random pose')&#13;
			try:&#13;
				robot.go_to_pose(Pose(x, y, 0, angle_z=degrees(z)), relative_to_robot=True).wait_for_completed()&#13;
			except:&#13;
				pass&#13;
			if robot.world.charger and robot.world.charger.pose.is_comparable(robot.pose):&#13;
				loops=0&#13;
				charger = robot.world.charger&#13;
				robot_print_current_state('found charger, breaking')&#13;
				robot_reaction_chance(cozmo.anim.Triggers.CodeLabSurprise,1,True,False,False)&#13;
				break&#13;
			else:&#13;
				robot_check_randomreaction()&#13;
				counter+=1&#13;
		# turn around for a bit&#13;
		counter=0&#13;
		while counter &lt;2 and cozmostate == 5:&#13;
			a= random.randrange(15, 46, 15)&#13;
			t= random.randrange(2, 4, 1)&#13;
			if random.choice((True, False)):&#13;
				rx=40&#13;
			else:&#13;
				rx=-40&#13;
			ry=-rx&#13;
			robot_print_current_state('looking for charger, rotating')&#13;
			try:&#13;
				robot.drive_wheels(rx, ry, l_wheel_acc=a, r_wheel_acc=a, duration=t)&#13;
			except:&#13;
				pass&#13;
			if robot.world.charger and robot.world.charger.pose.is_comparable(robot.pose):&#13;
				loops=0&#13;
				charger = robot.world.charger&#13;
				robot_print_current_state('found charger')&#13;
				cozmostate=6&#13;
				robot_reaction_chance(cozmo.anim.Triggers.CodeLabSurprise,1,True,False,False)&#13;
				break&#13;
			else:&#13;
				robot_check_randomreaction()&#13;
				counter+=1&#13;
		&#13;
		if charger:&#13;
			loops=0&#13;
			charger = robot.world.charger&#13;
			robot_print_current_state('found charger')&#13;
			robot_reaction_chance(cozmo.anim.Triggers.CodeLabSurprise,1,True,False,False)&#13;
			break&#13;
		robot_set_needslevel()&#13;
		robot_print_current_state('looking for charger, looping through random poses')&#13;
		loops=loops-1&#13;
	robot_print_current_state('looking for charger, broke out of drive loop')&#13;
	return charger&#13;
&#13;
#&#13;
# END OF ROBOT FUNCTIONS&#13;
#&#13;
# EVENT MONITOR FUNCTIONS&#13;
#&#13;
class CheckState (threading.Thread):&#13;
	global robot,cozmostate,freeplay,msg&#13;
	def __init__(self, thread_id, name, _q):&#13;
		threading.Thread.__init__(self)&#13;
		self.threadID = thread_id&#13;
		self.name = name&#13;
		self.q = _q&#13;
&#13;
# main thread&#13;
	def run(self):&#13;
		global robot,cozmostate,freeplay,msg&#13;
		delay = 10&#13;
		is_picked_up = False&#13;
		is_falling = False&#13;
		is_on_charger = False&#13;
		is_cliff_detected = False&#13;
		is_moving = False&#13;
		is_carrying_block = False&#13;
		is_localized = False&#13;
		is_picking_or_placing = False&#13;
		is_pathing = False&#13;
		oldcozmostate = 0&#13;
		while thread_running:&#13;
&#13;
# event monitor: robot is picked up detection&#13;
&#13;
			freeplayoldstatus=0&#13;
			if robot.is_picked_up:&#13;
				delay = 0&#13;
				if not is_picked_up:&#13;
					is_picked_up = True&#13;
					if cozmostate != 9:&#13;
						oldzcozmostate = cozmostate&#13;
						cozmostate = 9&#13;
					freeplayoldstatus=0&#13;
					if freeplay == 1:&#13;
						freeplayoldstatus=1&#13;
						robot.abort_all_actions(log_abort_messages=False)&#13;
						robot.enable_all_reaction_triggers(False)&#13;
						robot.stop_freeplay_behaviors()&#13;
						freeplay=0&#13;
					robot.abort_all_actions(log_abort_messages=False)&#13;
					#robot.wait_for_all_actions_completed()&#13;
					robot_reaction_chance(cozmo.anim.Triggers.AskToBeRightedLeft,1,False,False,False)&#13;
					if robot.is_cliff_detected:&#13;
						robot_reaction_chance(cozmo.anim.Triggers.TurtleRoll,1,False,False,False)&#13;
					if robot.is_cliff_detected:&#13;
						try:&#13;
							robot.set_lift_height(1,1,1,0.1).wait_for_completed()&#13;
						except:&#13;
							pass&#13;
						try:&#13;
							robot.drive_wheels(-40, -40, l_wheel_acc=30, r_wheel_acc=30, duration=1.0)&#13;
						except:&#13;
							pass&#13;
					if robot.is_cliff_detected:&#13;
						try:&#13;
							robot.set_lift_height(1,1,1,0.1).wait_for_completed()&#13;
						except:&#13;
							pass&#13;
						try:&#13;
							robot.drive_wheels(-40, -40, l_wheel_acc=30, r_wheel_acc=30, duration=1.0)&#13;
						except:&#13;
							pass&#13;
						try:&#13;
							robot.drive_wheels(-40, -40, l_wheel_acc=30, r_wheel_acc=30, duration=1.0)&#13;
						except:&#13;
							pass&#13;
						robot_reaction_chance(cozmo.anim.Triggers.TurtleRoll,1,False,False,False)&#13;
					if robot.is_cliff_detected:&#13;
						robot_reaction_chance(cozmo.anim.Triggers.CodeLabUnhappy,1,True,False,False)&#13;
					msg = 'state change: cozmo.robot.Robot.is_pickup_up: True'&#13;
					print(msg)&#13;
			elif is_picked_up and delay &gt; 9:&#13;
				if freeplayoldstatus==1:&#13;
					robot_reaction_chance(cozmo.anim.Triggers.VC_HowAreYouDoing_AllGood,1,False,False,False)&#13;
					freeplayoldstatus=0&#13;
					freeplay=1&#13;
					robot.start_freeplay_behaviors()&#13;
					robot.enable_all_reaction_triggers(True)&#13;
				is_picked_up = False&#13;
				cozmostate = oldcozmostate&#13;
				msg = 'state change: cozmo.robot.Robot.is_pickup_up: False'&#13;
				print(msg)&#13;
			elif delay &lt;= 9:&#13;
				delay += 1&#13;
				&#13;
# event monitor: robot is carrying a block&#13;
&#13;
			if robot.is_carrying_block:&#13;
				if not is_carrying_block:&#13;
					is_carrying_block = True&#13;
					msg = 'state change: cozmo.robot.Robot.is_carrying_block: True'&#13;
					print(msg)&#13;
			elif not robot.is_carrying_block:&#13;
				if is_carrying_block:&#13;
					is_carrying_block = False&#13;
					msg = 'state change: cozmo.robot.Robot.is_carrying_block: False'&#13;
					print(msg)&#13;
&#13;
# event monitor: robot is localized (I don't think this is working right now)&#13;
&#13;
			if robot.is_localized:&#13;
				if not is_localized:&#13;
					is_localized = True&#13;
					msg = 'state change: cozmo.robot.Robot.is_localized: True'&#13;
					print(msg)&#13;
			elif not robot.is_localized:&#13;
				if is_localized:&#13;
					is_localized = False&#13;
					msg = 'state change: cozmo.robot.Robot.is_localized: False'&#13;
					print(msg)					&#13;
&#13;
# event monitor: robot is falling&#13;
&#13;
			if robot.is_falling:&#13;
				if not is_falling:&#13;
					is_falling = True&#13;
					msg = 'state change: cozmo.robot.Robot.is_falling: True'&#13;
					cozmostate = 9&#13;
					print(msg)&#13;
			elif not robot.is_falling:&#13;
				if is_falling:&#13;
					is_falling = False&#13;
					msg = 'state change: cozmo.robot.Robot.is_falling: False'&#13;
					print(msg)&#13;
&#13;
# event monitor: robot is on charger&#13;
&#13;
			if robot.is_on_charger:&#13;
				if not is_on_charger:&#13;
					is_on_charger = True&#13;
					freeplay=0&#13;
					robot.abort_all_actions(log_abort_messages=False)&#13;
					#robot.wait_for_all_actions_completed()&#13;
					robot.stop_freeplay_behaviors()&#13;
					robot.enable_all_reaction_triggers(False)&#13;
					msg = 'state change: cozmo.robot.Robot.is_on_charger: True'&#13;
					robot_set_backpacklights(65535)  # 65535 is blue&#13;
					if robot.is_charging:&#13;
						cozmostate=1&#13;
					else:&#13;
						cozmostate=2&#13;
					print(msg)&#13;
			elif not robot.is_on_charger:&#13;
				if is_on_charger:&#13;
					robot_set_backpacklights(16711935)  # 16711935 is green&#13;
					is_on_charger = False&#13;
					cozmostate = 0&#13;
					msg = 'state change: cozmo.robot.Robot.is_on_charger: False'&#13;
					print(msg)&#13;
&#13;
# event monitor: robot has detected cliff&#13;
&#13;
			if robot.is_cliff_detected and not robot.is_falling and not robot.is_picked_up:&#13;
				if not is_cliff_detected:&#13;
					is_cliff_detected = True&#13;
					msg = 'state change: cozmo.robot.Robot.is_cliff_detected: True'&#13;
					print(msg)&#13;
					if freeplay == 1:&#13;
						freeplay = 0&#13;
						wasinfreeplay = 1&#13;
						robot.stop_freeplay_behaviors()&#13;
						robot.abort_all_actions(log_abort_messages=False)&#13;
						#robot.wait_for_all_actions_completed()&#13;
						time.sleep(1)&#13;
					try:&#13;
						robot.drive_wheels(-40, -40, l_wheel_acc=30, r_wheel_acc=30, duration=1.5)&#13;
					except:&#13;
						pass&#13;
					try:&#13;
						robot.drive_wheels(-40, -40, l_wheel_acc=30, r_wheel_acc=30, duration=1.5)&#13;
					except:&#13;
						pass&#13;
					robot.start_freeplay_behaviors()&#13;
					is_cliff_detected = False&#13;
					msg = 'state change: cozmo.robot.Robot.is_cliff_detected: False'&#13;
					print(msg)&#13;
			elif not robot.is_cliff_detected:&#13;
				if is_cliff_detected:&#13;
					is_cliff_detected = False&#13;
					if wasinfreeplay ==1:&#13;
						freeplay = 1&#13;
						wasinfreeplay = 0&#13;
						robot.start_freeplay_behaviors()&#13;
&#13;
# event monitor: robot is picking or placing something&#13;
			if robot.is_picking_or_placing:&#13;
				if not is_picking_or_placing:&#13;
					is_picking_or_placing = True&#13;
					msg = 'state change: cozmo.robot.Robot.is_picking_or_placing: True'&#13;
					print(msg)&#13;
			elif not robot.is_picking_or_placing:&#13;
				if is_picking_or_placing:&#13;
					is_picking_or_placing = False&#13;
					msg = 'state change: cozmo.robot.Robot.is_picking_or_placing: False'&#13;
					print(msg)		&#13;
				&#13;
# event monitor: robot is pathing (traveling to a target)&#13;
			if robot.is_pathing:&#13;
				if not is_pathing:&#13;
					is_pathing = True&#13;
					msg = 'state change: cozmo.robot.Robot.is_pathing: True'&#13;
					#print(msg)&#13;
			elif not robot.is_pathing:&#13;
				if is_pathing:&#13;
					is_pathing = False&#13;
					msg = 'state change: cozmo.robot.Robot.is_pathing: False'&#13;
					#print(msg)	&#13;
				&#13;
# event monitor: robot is moving&#13;
# too spammy/unreliable&#13;
&#13;
			# if robot.is_moving:&#13;
				# if not is_moving:&#13;
					# is_moving = True&#13;
					# msg = 'state change: cozmo.robot.Robot.is_moving: True'&#13;
					# print(msg)&#13;
			# elif not robot.is_moving:&#13;
				# if is_moving:&#13;
					# is_moving = False&#13;
					# msg = 'state change: cozmo.robot.Robot.is_moving: False'&#13;
					# print(msg)		&#13;
&#13;
# end of detection loop&#13;
&#13;
			time.sleep(0.1)&#13;
&#13;
def print_prefix(evt):&#13;
	msg = evt.event_name + ' '&#13;
	return msg&#13;
&#13;
def print_object(obj):&#13;
	if isinstance(obj,cozmo.objects.LightCube):&#13;
		cube_id = next(k for k,v in robot.world.light_cubes.items() if v==obj)&#13;
		msg = 'LightCube-' + str(cube_id)&#13;
	else:&#13;
		r = re.search('&lt;(\w*)', obj.__repr__())&#13;
		msg = r.group(1)&#13;
	return msg&#13;
&#13;
def monitor_generic(evt, **kwargs):&#13;
	global robot&#13;
	msg = print_prefix(evt)&#13;
	if 'behavior' in kwargs or 'behavior_type_name' in kwargs:&#13;
		msg += kwargs['behavior_type_name'] + ' '&#13;
		msg += kwargs['behavior'] + ' '&#13;
	if 'obj' in kwargs:&#13;
		msg += print_object(kwargs['obj']) + ' '&#13;
	if 'action' in kwargs:&#13;
		action = kwargs['action']&#13;
		if isinstance(action, cozmo.anim.Animation):&#13;
			msg += action.anim_name + ' '&#13;
		elif isinstance(action, cozmo.anim.AnimationTrigger):&#13;
			msg += action.trigger.name + ' '&#13;
	msg += str(set(kwargs.keys()))&#13;
	#print(msg)&#13;
#&#13;
# event monitor: robot is experiencing unexpected movement&#13;
#&#13;
def monitor_EvtUnexpectedMovement(evt, **kwargs):&#13;
	global robot,freeplay,cozmostate&#13;
	msg = kwargs&#13;
	print(msg)&#13;
	if  cozmostate != 3:&#13;
		print("state change: unexpected behavior during action; aborting")&#13;
		robot.abort_all_actions(log_abort_messages=False)&#13;
		#robot.wait_for_all_actions_completed()&#13;
		print("state change: unexpected behavior during action; aborting")&#13;
#&#13;
# event monitor: robot has completed an action&#13;
#&#13;
def monitor_EvtActionCompleted(evt, action, state, failure_code, failure_reason, **kwargs):&#13;
	msg = print_prefix(evt)&#13;
	msg += print_object(action) + ' '&#13;
	if isinstance(action, cozmo.anim.Animation):&#13;
		msg += action.anim_name&#13;
	elif isinstance(action, cozmo.anim.AnimationTrigger):&#13;
		msg += action.trigger.name&#13;
	if failure_code is not None:&#13;
		msg += str(failure_code) + failure_reason&#13;
#	print(msg)&#13;
#&#13;
# event monitor: an object was tapped&#13;
#&#13;
def monitor_EvtObjectTapped(evt, *, obj, tap_count, tap_duration, tap_intensity, **kwargs):&#13;
	msg = print_prefix(evt)&#13;
	msg += print_object(obj)&#13;
	msg += ' count=' + str(tap_count) + ' duration=' + str(tap_duration) + ' intensity=' + str(tap_intensity)&#13;
	print(msg)&#13;
#&#13;
# event monitor: a face was detected&#13;
#&#13;
def monitor_face(evt, face, **kwargs):&#13;
	msg = print_prefix(evt)&#13;
	name = face.name if face.name is not '' else '[unknown face]'&#13;
	expression = face.expression if face.expression is not '' else '[unknown expression]'&#13;
	msg += name + ' face_id=' + str(face.face_id) + ' looking ' + str(face.expression)&#13;
	print(msg)&#13;
#&#13;
# event monitor: an object started moving&#13;
#&#13;
def monitor_EvtObjectMovingStarted(evt, *, obj, acceleration, **kwargs):&#13;
	msg = print_prefix(evt)&#13;
	msg += print_object(obj) + ' '&#13;
	msg += ' accleration=' + str(acceleration)&#13;
	print(msg)&#13;
#&#13;
# event monitor: an object stopped moving&#13;
#&#13;
def monitor_EvtObjectMovingStopped(evt, *, obj, move_duration, **kwargs):&#13;
	msg = print_prefix(evt)&#13;
	msg += print_object(obj) + ' '&#13;
	msg += ' move_duration ' + str(move_duration) + 'secs'&#13;
	print(msg)&#13;
#&#13;
# event monitor: an object appeared in our vision&#13;
#&#13;
def monitor_EvtObjectAppeared(evt, **kwargs):&#13;
	global cozmostate&#13;
	msg = print_prefix(evt)&#13;
	msg += print_object(kwargs['obj']) + ' '&#13;
	if print_object(kwargs['obj']) == "Charger" and cozmostate == 5:&#13;
		print("its the charger and we're looking for it!")&#13;
		cozmostate = 6&#13;
	#print(msg)&#13;
&#13;
dispatch_table = {&#13;
  cozmo.action.EvtActionStarted        : monitor_generic,&#13;
  cozmo.action.EvtActionCompleted      : monitor_EvtActionCompleted,&#13;
  cozmo.behavior.EvtBehaviorStarted    : monitor_generic,&#13;
  cozmo.behavior.EvtBehaviorStopped    : monitor_generic,&#13;
  cozmo.anim.EvtAnimationsLoaded       : monitor_generic,&#13;
  cozmo.anim.EvtAnimationCompleted     : monitor_EvtActionCompleted,&#13;
  cozmo.objects.EvtObjectAppeared      : monitor_EvtObjectAppeared,&#13;
  cozmo.objects.EvtObjectDisappeared   : monitor_generic,&#13;
  cozmo.objects.EvtObjectMovingStarted : monitor_EvtObjectMovingStarted,&#13;
  cozmo.objects.EvtObjectMovingStopped : monitor_EvtObjectMovingStopped,&#13;
  cozmo.objects.EvtObjectObserved      : monitor_generic,&#13;
  cozmo.objects.EvtObjectTapped        : monitor_EvtObjectTapped,&#13;
  cozmo.faces.EvtFaceAppeared          : monitor_face,&#13;
  cozmo.faces.EvtFaceObserved          : monitor_face,&#13;
  cozmo.faces.EvtFaceDisappeared       : monitor_face,&#13;
  cozmo.robot.EvtUnexpectedMovement    : monitor_EvtUnexpectedMovement,&#13;
}&#13;
&#13;
excluded_events = {	# Occur too frequently to monitor by default&#13;
	cozmo.objects.EvtObjectObserved,&#13;
	cozmo.faces.EvtFaceObserved,&#13;
	cozmo.objects.EvtObjectDisappeared,&#13;
}&#13;
&#13;
def monitor(_robot, _q, evt_class=None):&#13;
	if not isinstance(_robot, cozmo.robot.Robot):&#13;
		raise TypeError('First argument must be a Robot instance')&#13;
	if evt_class is not None and not issubclass(evt_class, cozmo.event.Event):&#13;
		raise TypeError('Second argument must be an Event subclass')&#13;
	global robot&#13;
	global q&#13;
	global thread_running&#13;
	robot = _robot&#13;
	q = _q&#13;
	thread_running = True&#13;
	if evt_class in dispatch_table:&#13;
		robot.world.add_event_handler(evt_class,dispatch_table[evt_class])&#13;
	elif evt_class is not None:&#13;
		robot.world.add_event_handler(evt_class,monitor_generic)&#13;
	else:&#13;
		for k,v in dispatch_table.items():&#13;
			if k not in excluded_events:&#13;
				robot.world.add_event_handler(k,v)&#13;
	thread_is_state_changed = CheckState(1, 'ThreadCheckState', q)&#13;
	thread_is_state_changed.start()&#13;
&#13;
def unmonitor(_robot, evt_class=None):&#13;
	if not isinstance(_robot, cozmo.robot.Robot):&#13;
		raise TypeError('First argument must be a Robot instance')&#13;
	if evt_class is not None and not issubclass(evt_class, cozmo.event.Event):&#13;
		raise TypeError('Second argument must be an Event subclass')&#13;
	global robot&#13;
	global thread_running&#13;
	robot = _robot&#13;
	thread_running = False&#13;
&#13;
	try:&#13;
		if evt_class in dispatch_table:&#13;
			robot.world.remove_event_handler(evt_class,dispatch_table[evt_class])&#13;
		elif evt_class is not None:&#13;
			robot.world.remove_event_handler(evt_class,monitor_generic)&#13;
		else:&#13;
			for k,v in dispatch_table.items():&#13;
				robot.world.remove_event_handler(k,v)&#13;
	except Exception:&#13;
		pass&#13;
#&#13;
# END OF EVENT MONITOR FUNCTIONS&#13;
#&#13;
# START THE SHOW!&#13;
#&#13;
cozmo.robot.Robot.drive_off_charger_on_connect = False&#13;
#&#13;
#uncomment the below line to load the viewer &#13;
#cozmo.run_program(cozmo_unleashed, use_viewer=True)&#13;
#&#13;
# you may need to install a freeglut library, the cozmo SDK has documentation for this. If you don't have it comment the below line and uncomment the one above.&#13;
#cozmo.run_program(cozmo_unleashed, use_viewer=True, use_3d_viewer=True)&#13;
# which will give you remote control over Cozmo via WASD+QERF while the 3d window has focus&#13;
#&#13;
# below is just the program running without any camera view or 3d maps&#13;
cozmo.run_program(cozmo_unleashed)</script>
        <sys_created_by>Arnoud.Kooi</sys_created_by>
        <sys_created_on>2018-07-19 14:03:19</sys_created_on>
        <sys_id>50aeb3474fd3134035e0fdb28110c799</sys_id>
        <sys_mod_count>0</sys_mod_count>
        <sys_updated_by>Arnoud.Kooi</sys_updated_by>
        <sys_updated_on>2018-07-19 14:03:19</sys_updated_on>
        <test_parameters>Goodevening how are you?</test_parameters>
    </x_snc_cozmo_guard_python_commands>
</record_update>
]]></payload>
        <sys_class_name>sys_metadata_link</sys_class_name>
        <sys_created_by>Arnoud.Kooi</sys_created_by>
        <sys_created_on>2019-03-05 21:13:42</sys_created_on>
        <sys_customer_update>false</sys_customer_update>
        <sys_id>2935704d4f8c33009881c5c18110c79e</sys_id>
        <sys_mod_count>0</sys_mod_count>
        <sys_name>unleash.py</sys_name>
        <sys_package display_value="Cozmo Guard" source="x_snc_cozmo_guard">2df0e27d4fdf1f009881c5c18110c780</sys_package>
        <sys_policy/>
        <sys_replace_on_upgrade>false</sys_replace_on_upgrade>
        <sys_scope display_value="Cozmo Guard">2df0e27d4fdf1f009881c5c18110c780</sys_scope>
        <sys_update_name>sys_metadata_link_2935704d4f8c33009881c5c18110c79e</sys_update_name>
        <sys_updated_by>Arnoud.Kooi</sys_updated_by>
        <sys_updated_on>2019-03-05 21:13:42</sys_updated_on>
        <tablename>x_snc_cozmo_guard_python_commands</tablename>
    </sys_metadata_link>
</record_update>
