<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_metadata_link">
    <sys_metadata_link action="INSERT_OR_UPDATE">
        <directory>update</directory>
        <documentkey>6d79308a4f575f009881c5c18110c7b0</documentkey>
        <payload><![CDATA[<?xml version="1.0" encoding="UTF-8"?><record_update table="x_snc_cozmo_guard_python_commands">
    <x_snc_cozmo_guard_python_commands action="INSERT_OR_UPDATE">
        <active>false</active>
        <file_name>color_finder.py</file_name>
        <name>Color Finder</name>
        <script>#!/usr/bin/env python3&#13;
&#13;
&#13;
'''Cozmo looks around and drives after colors.&#13;
&#13;
Place a tennis ball near Cozmo and see if he can go play with it!&#13;
&#13;
When the program starts, Cozmo will look around for the color yellow.&#13;
Tap the cube illuminated yellow to switch Cozmo's target color between yellow, blue, red, and green.&#13;
Tap the blinking white cube to have the viewer display Cozmo's pixelated camera view.&#13;
'''&#13;
&#13;
import asyncio&#13;
import functools&#13;
import math&#13;
import numpy&#13;
import sys&#13;
&#13;
import cozmo&#13;
&#13;
from cozmo.util import degrees, distance_mm, radians, speed_mmps, Vector2&#13;
from cozmo.lights import Color, Light&#13;
try:&#13;
    from PIL import Image, ImageColor, ImageDraw, ImageStat&#13;
except ImportError:&#13;
    sys.exit('Cannot import from PIL: Do `pip3 install --user Pillow` to install')&#13;
&#13;
&#13;
# Set ENABLE_COLOR_BALANCING to False to skip the color_balance step&#13;
ENABLE_COLOR_BALANCING = True&#13;
&#13;
&#13;
# map_color_to_light (dict): maps each color name with its cozmo.lights.Light value.&#13;
# Red, green, and blue lights are already defined as constants in lights.py, &#13;
# but we need to define our own custom Light for yellow.&#13;
map_color_to_light = {&#13;
'green' : cozmo.lights.green_light, &#13;
'yellow' : Light(Color(name='yellow', rgb = (255, 255, 0))), &#13;
'blue' : cozmo.lights.blue_light, &#13;
'red' : cozmo.lights.red_light&#13;
}&#13;
&#13;
# hsv_color_ranges (dict): map of color names to regions in HSV space.&#13;
# Instead of defining a color as a single (H, S, V) point, &#13;
# colors are defined with a minimum and maximum value for H, S, and V.&#13;
# For example, a point with (H, S, V) = (200.0, 0.8, 0.95) falls entirely in the 'blue' region, &#13;
# because 180.0 &lt; 200.0 &lt; 245.0, 0 &lt; 0.8 &lt; 1.0, and 0 &lt; 0.95 &lt; 1.0.&#13;
# A point with (H, S, V) = (88.0, 0.4, 0.9) does not fall exactly in one color region.&#13;
# But applying hsv_color_distance_sqr between this color and all the colors in hsv_color_ranges&#13;
# will show that (88.0, 0.4, 0.9) is closest to the 'green' region.&#13;
&#13;
hsv_color_ranges = {&#13;
'red' : (-20.0, 20.0, 0.5, 1.0, 0.5, 1.0), &#13;
'green' : (90.0, 155.0, 0.5, 1.0, 0.5, 1.0), &#13;
'blue' : (180.0, 245.0, 0.5, 1.0, 0.5, 1.0), &#13;
'yellow' : (40.0, 80.0, 0.5, 1.0, 0.5, 1.0), &#13;
'white' : (0.0, 360.0, 0.0, 0.2, 0.9, 1.0), &#13;
'black' : (0.0, 360.0, 0.0, 0.1, 0.0, 0.2)&#13;
}&#13;
&#13;
def hsv_color_distance_sqr(color, color_range):&#13;
    '''Determines the squared euclidean distance between color and color_range.&#13;
&#13;
    Note that we normalize h, minH, and maxH so that they also fall between 0 and 1, instead of 0 and 360.&#13;
&#13;
    Args:&#13;
        color (float, float, float): the H, S, V values of the color&#13;
        color_range(float, float, float, float, float, float): the minimum and maximum for H, S, and V for the color range&#13;
&#13;
    Returns:&#13;
        squared distance between color and color_range, &#13;
        which is the sum of the squared distances from &#13;
        the H, S, V values to their respective ranges&#13;
    '''&#13;
    h, s, v = color&#13;
    minH, maxH, minS, maxS, minV, maxV = color_range&#13;
    h_dist_sqr = 0&#13;
    s_dist_sqr = 0&#13;
    v_dist_sqr = 0&#13;
    if h &lt; minH:&#13;
        h_dist_sqr = (minH - h) ** 2&#13;
    elif h &gt; maxH:&#13;
        h_dist_sqr = (maxH - h) ** 2&#13;
    if s &lt; minS:&#13;
        s_dist_sqr = (minS - s) ** 2&#13;
    elif s &gt; maxS:&#13;
        s_dist_sqr = (maxS - s) ** 2&#13;
    if v &lt; minV:&#13;
        v_dist_sqr = (minV - v) ** 2&#13;
    elif v &gt; maxV:&#13;
        v_dist_sqr = (maxV - v) ** 2&#13;
    sum_dist_sqr = h_dist_sqr + s_dist_sqr + v_dist_sqr&#13;
    return sum_dist_sqr&#13;
&#13;
def color_balance(image):&#13;
    '''Adjusts the color data of an image so that the average R, G, B values across the entire image end up equal.&#13;
&#13;
    This is called a 'gray-world' algorithm, because the colors&#13;
    with equal R, G, B values fall along the grayscale.&#13;
    https://web.stanford.edu/~sujason/ColorBalancing/grayworld.html&#13;
&#13;
    Args:&#13;
        image (PIL image): the image being color-balanced&#13;
&#13;
    Returns&#13;
        the PIL image with balanced color distribution&#13;
    '''&#13;
    image_array = image_to_array(image)&#13;
    image_array = image_array.transpose(2, 0, 1).astype(numpy.uint32)&#13;
    average_g = numpy.average(image_array[1])&#13;
    image_array[0] = numpy.minimum(image_array[0] * (average_g / numpy.average(image_array[0])), 255)&#13;
    image_array[2] = numpy.minimum(image_array[2] * (average_g / numpy.average(image_array[2])), 255)&#13;
    return array_to_image(image_array.transpose(1, 2, 0).astype(numpy.uint8))&#13;
&#13;
def image_to_array(image):&#13;
    '''Converts PIL image to image array.'''&#13;
    image_array = numpy.asarray(image)&#13;
    image_array.flags.writeable = True&#13;
    return image_array&#13;
&#13;
def array_to_image(image_array):&#13;
    '''Coverts image array to PIL image.'''&#13;
    return Image.fromarray(numpy.uint8(image_array))&#13;
&#13;
def rgb_to_hsv(r, g, b):&#13;
    '''Converts an RGB value to its corresponding HSV value.&#13;
&#13;
    Args:&#13;
        r (int): the amount of red in the color, between 0 and 255&#13;
        g (int): the amount of green in the color, between 0 and 255&#13;
        b (int): the amount of blue in the color, between 0 and 255&#13;
&#13;
    Returns:&#13;
        tuple of floats (h, s, v) representing the HSV value of the color&#13;
        h represents an angle, between 0 and 360 degrees&#13;
        s represents the saturation, between 0 and 1&#13;
        v represents the brightness, between 0 and 1&#13;
    '''&#13;
    r_normalized = r / 255.0&#13;
    g_normalized = g / 255.0&#13;
    b_normalized = b / 255.0&#13;
    max_normalized_val = max(r_normalized, g_normalized, b_normalized)&#13;
    min_normalized_val = min(r_normalized, g_normalized, b_normalized)&#13;
    delta = max_normalized_val - min_normalized_val&#13;
&#13;
    h = 0&#13;
    s = 0&#13;
    v = max_normalized_val&#13;
&#13;
    if delta != 0:&#13;
        if max_normalized_val == r_normalized:&#13;
            h = 60.0 * ((g_normalized - b_normalized) / delta)&#13;
        elif max_normalized_val == g_normalized:&#13;
            h = 60.0 * (((b_normalized - r_normalized) / delta) + 2)&#13;
        else:&#13;
            h = 60.0 * (((r_normalized - g_normalized) / delta) + 4)&#13;
        if h &lt; 0:&#13;
            h += 360&#13;
&#13;
        if max_normalized_val == 0:&#13;
            s = 0&#13;
        else:&#13;
            s = delta / max_normalized_val&#13;
    return (h, s, v)&#13;
&#13;
POSSIBLE_COLORS_TO_FIND = ['green', 'yellow', 'blue', 'red']&#13;
&#13;
LOOK_AROUND_STATE = 'look_around'&#13;
FOUND_COLOR_STATE = 'found_color'&#13;
DRIVING_STATE = 'driving'&#13;
&#13;
ANNOTATOR_WIDTH = 640.0&#13;
ANNOTATOR_HEIGHT = 480.0&#13;
&#13;
DOWNSIZE_WIDTH = 32&#13;
DOWNSIZE_HEIGHT = 24&#13;
&#13;
&#13;
class ColorFinder(cozmo.annotate.Annotator):&#13;
    '''Cozmo looks around and drives after colors.&#13;
&#13;
    Cozmo's camera view is approximated into a matrix of colors.&#13;
    Cozmo will look around for self.color_to_find, and once it is spotted, &#13;
    he will drive in the direction of that color.&#13;
&#13;
    Args:&#13;
        robot (cozmo.robot.Robot): instance of the robot connected from run_program.&#13;
    '''&#13;
    def __init__(self, robot: cozmo.robot.Robot):&#13;
        self.robot = robot&#13;
        self.robot.camera.image_stream_enabled = True&#13;
        self.robot.camera.color_image_enabled = True&#13;
        self.fov_x  = self.robot.camera.config.fov_x&#13;
        self.fov_y = self.robot.camera.config.fov_y&#13;
        self.robot.add_event_handler(cozmo.objects.EvtObjectTapped, self.on_cube_tap)&#13;
        self.robot.add_event_handler(cozmo.world.EvtNewCameraImage, self.on_new_camera_image)&#13;
&#13;
        self.color_selector_cube = None # type: LightCube&#13;
        self.color_to_find = 'yellow'&#13;
        self.color_to_find_index = POSSIBLE_COLORS_TO_FIND.index(self.color_to_find)&#13;
&#13;
        self.grid_cube = None # type: LightCube&#13;
        self.robot.world.image_annotator.add_annotator('color_finder', self)&#13;
        self.robot.world.image_annotator.annotation_enabled = False&#13;
        self.enabled = True&#13;
        self.pixel_matrix = MyMatrix(DOWNSIZE_WIDTH, DOWNSIZE_HEIGHT)&#13;
&#13;
        self.amount_turned_recently = radians(0)&#13;
        self.moving_threshold = radians(12)&#13;
&#13;
        self.state = LOOK_AROUND_STATE&#13;
&#13;
        self.look_around_behavior = None # type: LookAroundInPlace behavior&#13;
        self.drive_action = None # type: DriveStraight action&#13;
        self.tilt_head_action = None # type: SetHeadAngle action&#13;
        self.rotate_action = None # type: TurnInPlace action&#13;
        self.lift_action = None # type: SetLiftHeight action&#13;
&#13;
        self.last_known_blob_center = (DOWNSIZE_WIDTH/2, DOWNSIZE_HEIGHT/2) # initially set to center screen&#13;
&#13;
        self.white_balance_cube = None # type: LightCube&#13;
        self.adjustment = None&#13;
&#13;
    def apply(self, image, scale):&#13;
        '''Draws a pixelated grid of Cozmo's approximate camera view onto the viewer window.&#13;
        Also draws a marker showing the center of the largest blob that matches the color_to_find&#13;
            &#13;
        WM and HM are multipliers that scale the dimensions of the annotated squares &#13;
        based on DOWNSIZE_WIDTH and DOWNSIZE_HEIGHT&#13;
        '''&#13;
        d = ImageDraw.Draw(image)&#13;
        WM = ANNOTATOR_WIDTH/DOWNSIZE_WIDTH&#13;
        HM = ANNOTATOR_HEIGHT/DOWNSIZE_HEIGHT&#13;
&#13;
        for i in range(DOWNSIZE_WIDTH):&#13;
            for j in range(DOWNSIZE_HEIGHT):&#13;
                pt1 = Vector2(i * WM, j * HM)&#13;
                pt2 = Vector2(i * WM, (j + 1) * HM)&#13;
                pt3 = Vector2((i + 1) * WM, (j + 1) * HM)&#13;
                pt4 = Vector2((i + 1) * WM, j * HM)&#13;
                points_seq = (pt1, pt2, pt3, pt4)&#13;
                cozmo.annotate.add_polygon_to_image(image, points_seq, 1.0, 'green', self.pixel_matrix.at(i, j).value)&#13;
&#13;
        text = cozmo.annotate.ImageText('Looking for {}'.format(self.color_to_find), color = 'white')&#13;
        text.render(d, (0, 0, image.width, image.height))&#13;
&#13;
        if self.state != LOOK_AROUND_STATE:&#13;
            x, y = self.last_known_blob_center&#13;
            pt1 = Vector2((x + 0.5) * WM, (y + 0.5) * HM)&#13;
            pt2 = Vector2((x + 1.5) * WM, (y + 0.5) * HM)&#13;
            pt3 = Vector2((x + 1.5) * WM, (y + 1.5) * HM)&#13;
            pt4 = Vector2((x + 0.5) * WM, (y + 1.5) * HM)&#13;
            points_seq = (pt1, pt2, pt3, pt4)&#13;
            cozmo.annotate.add_polygon_to_image(image, points_seq, 1.0, 'black', 'gold')&#13;
&#13;
    def on_cube_tap(self, evt, obj, **kwargs):&#13;
        '''The blinking white cube switches the viewer between normal mode and pixel mode.&#13;
        The other illuminated cube toggles self.color_to_find.       &#13;
        '''    &#13;
        if obj.object_id == self.color_selector_cube.object_id:&#13;
            self.toggle_color_to_find()&#13;
        elif obj.object_id == self.grid_cube.object_id:&#13;
            self.robot.world.image_annotator.annotation_enabled = not self.robot.world.image_annotator.annotation_enabled&#13;
        elif obj.object_id == self.white_balance_cube.object_id:&#13;
            self.white_balance()&#13;
&#13;
    def toggle_color_to_find(self):&#13;
        '''Sets self.color_to_find to the next color in POSSIBLE_COLORS_TO_FIND.'''    &#13;
        self.color_to_find_index += 1&#13;
        if self.color_to_find_index == len(POSSIBLE_COLORS_TO_FIND):&#13;
            self.color_to_find_index = 0&#13;
        self.color_to_find = POSSIBLE_COLORS_TO_FIND[self.color_to_find_index]&#13;
        self.color_selector_cube.set_lights(map_color_to_light[self.color_to_find])&#13;
&#13;
    def on_new_camera_image(self, evt, **kwargs):&#13;
        '''Processes the blobs in Cozmo's view, and determines the correct reaction.'''&#13;
        downsized_image = self.get_low_res_view()&#13;
        if ENABLE_COLOR_BALANCING:&#13;
            downsized_image = color_balance(downsized_image)&#13;
        self.update_pixel_matrix(downsized_image)&#13;
        blob_detector = BlobDetector(self.pixel_matrix, self.color_to_find)&#13;
        blob_center = blob_detector.get_blob_center()&#13;
        if blob_center:&#13;
            self.last_known_blob_center = blob_center&#13;
            blob_size = blob_detector.get_blob_size()&#13;
            if self.state == LOOK_AROUND_STATE:&#13;
                self.state = FOUND_COLOR_STATE&#13;
                if self.look_around_behavior:&#13;
                    self.look_around_behavior.stop()&#13;
                    self.look_around_behavior = None&#13;
            self.on_finding_a_blob(blob_center, blob_size)&#13;
        else:&#13;
            self.robot.set_backpack_lights_off()&#13;
            self.abort_actions(self.drive_action)&#13;
            self.state = LOOK_AROUND_STATE&#13;
&#13;
    def white_balance(self):&#13;
        image = self.robot.world.latest_image.raw_image&#13;
        self.adjustment = ImageStat.Stat(image).mean&#13;
&#13;
    def update_pixel_matrix(self, downsized_image):&#13;
        '''Updates self.pixel_matrix with the colors from the current camera view.&#13;
&#13;
        Args:&#13;
            downsized_image (PIL image): the low-resolution version of self.robot.world.latest_image&#13;
        '''&#13;
        for i in range(self.pixel_matrix.num_cols):&#13;
            for j in range(self.pixel_matrix.num_rows):&#13;
                r, g, b = downsized_image.getpixel((i, j))&#13;
                self.pixel_matrix.at(i, j).set(self.approximate_color_of_pixel(r, g, b))&#13;
        self.pixel_matrix.fill_gaps()&#13;
&#13;
    def approximate_color_of_pixel(self, r, g, b):&#13;
        '''Returns the approximated color of the RGB value of a pixel.&#13;
&#13;
        Args:&#13;
            r (int): the amount of red in the pixel&#13;
            g (int): the amount of green in the pixel&#13;
            b (int): the amount of blue in the pixel&#13;
&#13;
        Returns:&#13;
            string specifying the name of the color range closest to the input color&#13;
        '''&#13;
        min_distance = sys.maxsize&#13;
        closest_color = ''&#13;
        h, s, v = rgb_to_hsv(r, g, b)&#13;
        if h &gt; 340.0:&#13;
            h -= 360.0&#13;
        for color_name, color_range in hsv_color_ranges.items():&#13;
            d = hsv_color_distance_sqr((h, s, v), color_range)&#13;
            if d &lt; min_distance:&#13;
                min_distance = d&#13;
                closest_color = color_name&#13;
        return closest_color&#13;
&#13;
    def get_low_res_view(self):&#13;
        '''Downsizes Cozmo's camera view to the specified dimensions.&#13;
&#13;
        Returns:&#13;
            PIL image downsized to low-resolution version of Cozmo's camera view.&#13;
        '''&#13;
        image = self.robot.world.latest_image.raw_image&#13;
        downsized_image = image.resize((DOWNSIZE_WIDTH, DOWNSIZE_HEIGHT), resample = Image.LANCZOS)&#13;
        return downsized_image&#13;
&#13;
    def on_finding_a_blob(self, blob_center, blob_size):&#13;
        '''Determines whether Cozmo should continue to look at the blob, or drive towards it.&#13;
            &#13;
        Args:&#13;
            blob_center (int, int): coordinates of the blob's center in self.pixel_matrix&#13;
            blob_size (int): number of pixels in the blob&#13;
        '''&#13;
        self.robot.set_center_backpack_lights(map_color_to_light[self.color_to_find])&#13;
        if blob_size &gt; (self.pixel_matrix.size/4):&#13;
            self.lift_action = self.robot.set_lift_height(0.0, in_parallel=True)&#13;
        x, y = blob_center&#13;
        # 'fov' stands for 'field of view'. This is the angle amount&#13;
        # that Cozmo can see to the edges of his camera view.&#13;
        amount_to_move_head = radians(self.fov_y.radians*(.5-float(y)/DOWNSIZE_HEIGHT))&#13;
        amount_to_rotate = radians(self.fov_x.radians*(.5-float(x)/DOWNSIZE_WIDTH))&#13;
        if self.moved_too_far_from_center(amount_to_move_head, amount_to_rotate):&#13;
            self.state = FOUND_COLOR_STATE&#13;
        if self.state != DRIVING_STATE:&#13;
            self.turn_toward_blob(amount_to_move_head, amount_to_rotate)&#13;
        else:&#13;
            self.drive_toward_color_blob()&#13;
&#13;
    def moved_too_far_from_center(self, amount_to_move_head, amount_to_rotate):&#13;
        '''Decides whether the center of the blob is too far from the center of Cozmo's view.&#13;
&#13;
        Args:&#13;
            amount_to_move_head (cozmo.util.Angle): &#13;
                the perceived vertical distance of the blob from center-screen&#13;
            amount_to_rotate (cozmo.util.Angle): &#13;
                the perceived horizontal distance of the blob from center-screen&#13;
&#13;
        Returns:&#13;
            bool specifying whether the object is too far from center-screen&#13;
        '''&#13;
        too_far_vertical = (amount_to_move_head.abs_value &gt; self.fov_y/4)&#13;
        too_far_horizontal = (amount_to_rotate.abs_value &gt; self.fov_x/4)&#13;
        too_far = too_far_vertical or too_far_horizontal&#13;
        return too_far&#13;
&#13;
    def turn_toward_blob(self, amount_to_move_head, amount_to_rotate):&#13;
        '''Calls actions that tilt Cozmo's head and rotate his body toward the color.&#13;
&#13;
        Args:&#13;
           amount_to_move_head (cozmo.util.Angle): &#13;
               the perceived vertical distance of the blob from center-screen&#13;
           amount_to_rotate (cozmo.util.Angle): &#13;
               the perceived horizontal distance of the blob from center-screen&#13;
        '''&#13;
        self.abort_actions(self.tilt_head_action, self.rotate_action, self.drive_action)&#13;
        new_head_angle = self.robot.head_angle + amount_to_move_head&#13;
        self.tilt_head_action = self.robot.set_head_angle(new_head_angle, warn_on_clamp=False, in_parallel=True)&#13;
        self.rotate_action = self.robot.turn_in_place(amount_to_rotate, in_parallel=True)&#13;
        if self.state == FOUND_COLOR_STATE:&#13;
            self.amount_turned_recently += amount_to_move_head.abs_value + amount_to_rotate.abs_value&#13;
&#13;
    def drive_toward_color_blob(self):&#13;
        '''Drives straight once prior actions have been cancelled.'''&#13;
        self.abort_actions(self.tilt_head_action, self.rotate_action)&#13;
        if self.should_start_new_action(self.drive_action):&#13;
            self.drive_action = self.robot.drive_straight(distance_mm(500), speed_mmps(300), should_play_anim=False, in_parallel=True)&#13;
        if self.should_start_new_action(self.lift_action):&#13;
            self.lift_action = self.robot.set_lift_height(1.0, in_parallel=True)&#13;
&#13;
    def turn_toward_last_known_blob(self):&#13;
        '''Turns toward the coordinates of the last recorded blob in memory.&#13;
&#13;
        amount_to_rotate is multiplied to overshoot the object rather than undershoot it.&#13;
        '''&#13;
        x, y = self.last_known_blob_center&#13;
        amount_to_move_head = radians(self.fov_y.radians*(.5-y/DOWNSIZE_HEIGHT))&#13;
        amount_to_rotate = radians(self.fov_x.radians*(.5-x/DOWNSIZE_WIDTH)) * 4&#13;
        self.turn_toward_blob(amount_to_move_head, amount_to_rotate)&#13;
&#13;
    def abort_actions(self, *actions):&#13;
        '''Aborts the input actions if they are currently running.&#13;
&#13;
        Args:&#13;
            *actions (list): the list of actions&#13;
        '''&#13;
        for action in actions:&#13;
            if action != None and action.is_running:&#13;
                action.abort()&#13;
&#13;
    def should_start_new_action(self, action):&#13;
        ''' Whether the action should be started.&#13;
&#13;
        Args:&#13;
            action (action): the action that should or should not be started&#13;
&#13;
        Returns:&#13;
            bool specifying whether the action is not running or is currently None&#13;
        '''&#13;
        should_start = ((action == None) or (not action.is_running))&#13;
        return should_start&#13;
&#13;
    async def start_lookaround(self):&#13;
        '''Turns to a likely spot for a blob to be, then starts self.look_around_behavior.'''&#13;
        if self.look_around_behavior == None or not self.look_around_behavior.is_active:&#13;
            self.turn_toward_last_known_blob()&#13;
            await asyncio.sleep(.5)&#13;
            if self.state == LOOK_AROUND_STATE: # state may have changed due to turn_toward_last_known_blob&#13;
                self.abort_actions(self.tilt_head_action, self.rotate_action, self.drive_action)&#13;
                self.look_around_behavior = self.robot.start_behavior(cozmo.behavior.BehaviorTypes.LookAroundInPlace)&#13;
&#13;
    def turn_on_cubes(self):&#13;
        '''Illuminates the two cubes that control self.color_to_find and set the viewer display.'''&#13;
        self.color_selector_cube.set_lights(map_color_to_light[self.color_to_find])&#13;
        self.grid_cube.set_lights(cozmo.lights.white_light.flash())&#13;
&#13;
    def cubes_connected(self):&#13;
        '''Returns true if Cozmo connects to both cubes successfully.'''   &#13;
        self.color_selector_cube = self.robot.world.get_light_cube(cozmo.objects.LightCube1Id)&#13;
        self.grid_cube = self.robot.world.get_light_cube(cozmo.objects.LightCube2Id)&#13;
        self.white_balance_cube = self.robot.world.get_light_cube(cozmo.objects.LightCube3Id)&#13;
        return not (self.color_selector_cube == None or self.grid_cube == None or self.white_balance_cube == None)&#13;
&#13;
    async def run(self):&#13;
        '''Program runs until typing CRTL+C into Terminal/Command Prompt, &#13;
        or by closing the viewer window.&#13;
        '''    &#13;
        if not self.cubes_connected():&#13;
            print('Cubes did not connect successfully - check that they are nearby. You may need to replace the batteries.')&#13;
            return&#13;
        self.turn_on_cubes()&#13;
        await self.robot.drive_straight(distance_mm(100), speed_mmps(50), should_play_anim = False).wait_for_completed()&#13;
&#13;
        # Updates self.state and resets self.amount_turned_recently every 1 second.&#13;
        while True:&#13;
            await asyncio.sleep(1)&#13;
            if self.state == LOOK_AROUND_STATE:&#13;
                await self.start_lookaround()&#13;
            if self.state == FOUND_COLOR_STATE and self.amount_turned_recently &lt; self.moving_threshold:&#13;
                self.state = DRIVING_STATE&#13;
            self.amount_turned_recently = radians(0)&#13;
&#13;
&#13;
class BlobDetector():&#13;
    '''Determine where the regions of the specified color reside in a matrix.&#13;
&#13;
    We use this class to find the areas of color_to_find in the pixel_matrix of the ColorFinder class.&#13;
    &#13;
    Args:&#13;
        matrix (int[][]) : the pixel_matrix from ColorFinder&#13;
        keylist (list of strings): the list of possible_colors_to_find from ColorFinder&#13;
        color_to_find (string): the color of the blobs Cozmo is looking for&#13;
    '''&#13;
    def __init__(self, matrix, color_to_find):&#13;
        self.matrix = matrix&#13;
        self.color_to_find = color_to_find&#13;
&#13;
        self.num_blobs = 1&#13;
        self.blobs_dict = {}&#13;
        self.keys = MyMatrix(self.matrix.num_cols, self.matrix.num_rows)&#13;
        self.make_blobs_dict()&#13;
        self.filter_blobs_dict_by_size(5) # prevents a lot of irrelevant blobs from being processed&#13;
        self.largest_blob_size = 0&#13;
&#13;
    def make_blobs_dict(self):&#13;
        '''Using a connected components algorithm, constructs a dictionary &#13;
        that maps a blob to the points of the matrix that make up that blob.&#13;
&#13;
        Only creates a blob if the point's color matches self.color_to_find.&#13;
&#13;
        Key and Value types of the dictionary:&#13;
            Key : int specifying self.num_blobs at the time the blob was first created.&#13;
            Value : the list of points in the blob.&#13;
        '''&#13;
        for i in range(self.matrix.num_cols):&#13;
            for j in range(self.matrix.num_rows):&#13;
                if self.matrix.at(i, j).value == self.color_to_find:&#13;
                    matches_left = self.matches_blob_left(i, j)&#13;
                    matches_above = self.matches_blob_above(i, j)&#13;
                    should_merge = matches_left and matches_above and self.above_and_left_blobs_are_different(i, j)&#13;
                    if should_merge:&#13;
                        self.merge_up_and_left_blobs(i, j)&#13;
                    elif matches_left:&#13;
                        self.join_blob_left(i, j)&#13;
                    elif matches_above:&#13;
                        self.join_blob_above(i, j)&#13;
                    else:&#13;
                        self.make_new_blob_at(i, j)&#13;
&#13;
    def matches_blob_above(self, i, j):&#13;
        '''Returns true if the current point matches the point above.&#13;
&#13;
        Args:&#13;
            i (int): the x-coordinate in self.matrix&#13;
            j (int): the y-coordinate in self.matrix&#13;
&#13;
        Returns:&#13;
            bool specifying whether the current point matches the point above.&#13;
        '''&#13;
        if j == 0:&#13;
            return False&#13;
        matches_above = (self.matrix.at(i, j-1).value == self.color_to_find)&#13;
        return matches_above&#13;
&#13;
    def matches_blob_left(self, i, j):&#13;
        '''Returns true if the current point matches the point to the left.&#13;
&#13;
        Args:&#13;
            i (int): the x-coordinate in self.matrix&#13;
            j (int): the y-coordinate in self.matrix&#13;
&#13;
        Returns:&#13;
            bool specifying whether the current point matches the point to the left.&#13;
        '''&#13;
        if i == 0:&#13;
            return False&#13;
        matches_left  = (self.matrix.at(i-1, j).value == self.color_to_find)&#13;
        return matches_left&#13;
&#13;
    def above_and_left_blobs_are_different(self, i, j):&#13;
        '''Returns true if the point above and the point to the left belong to different blobs.&#13;
&#13;
        Args:&#13;
            i (int): the x-coordinate in self.matrix&#13;
            j (int): the y-coordinate in self.matrix&#13;
&#13;
        Returns:&#13;
            bool specifying whether the above blob and the left blob have different keys in self.keys&#13;
        '''&#13;
        if i == 0 or j == 0:&#13;
            return False&#13;
        above_and_left_different = (self.keys.at(i-1, j).value != self.keys.at(i, j-1).value)&#13;
        return above_and_left_different&#13;
&#13;
    def make_new_blob_at(self, i, j):&#13;
        '''Adds a new blob to self.blob_dict &#13;
        whose list of points initially contains only the current point.&#13;
&#13;
        Args:&#13;
            i (int): the x-coordinate in self.matrix&#13;
            j (int): the y-coordinate in self.matrix&#13;
        '''&#13;
        self.blobs_dict[self.num_blobs] = [(i, j)]&#13;
        self.keys.at(i, j).set(self.num_blobs)&#13;
        self.num_blobs += 1&#13;
&#13;
    def join_blob_above(self, i, j):&#13;
        '''Adds current point to the blob above.&#13;
&#13;
        Args:&#13;
            i (int): the x-coordinate in self.matrix&#13;
            j (int): the y-coordinate in self.matrix&#13;
        '''&#13;
        above_blob_key = self.keys.at(i, j-1).value&#13;
        self.blobs_dict[above_blob_key].append((i, j))&#13;
        self.keys.at(i, j).set(above_blob_key)&#13;
&#13;
    def join_blob_left(self, i, j):&#13;
        '''Adds current point to the blob to the left.&#13;
&#13;
        Args:&#13;
            i (int): the x-coordinate in self.matrix&#13;
            j (int): the y-coordinate in self.matrix&#13;
        '''&#13;
        left_blob_key = self.keys.at(i-1, j).value&#13;
        self.blobs_dict[left_blob_key].append((i, j))&#13;
        self.keys.at(i, j).set(left_blob_key)&#13;
&#13;
    def merge_up_and_left_blobs(self, i, j):&#13;
        '''Adds current point and points from the above blob into left blob, &#13;
        then removes the above blob from self.blob_dict&#13;
&#13;
        Args:&#13;
            i (int): the x-coordinate in self.matrix&#13;
            j (int): the y-coordinate in self.matrix&#13;
        '''&#13;
        above_blob_key = self.keys.at(i, j-1).value&#13;
        left_blob_key = self.keys.at(i-1, j).value&#13;
        above_blob_points = self.blobs_dict[above_blob_key]&#13;
        left_blob_points = self.blobs_dict[left_blob_key]&#13;
        for point in above_blob_points:&#13;
            self.blobs_dict[left_blob_key].append(point)&#13;
        self.blobs_dict[left_blob_key].append((i, j))&#13;
        self.keys.at(i, j).set(left_blob_key)&#13;
        for (x, y) in above_blob_points:&#13;
            self.keys.at(x, y).set(left_blob_key)&#13;
        self.blobs_dict.pop(above_blob_key)&#13;
&#13;
    def filter_blobs_dict_by_size(self, n):&#13;
        '''Filters out small blobs from self.blobs_dict.&#13;
&#13;
        Args:&#13;
            n (int): the number of points required of a blob to stay in self.blobs_dict&#13;
        '''&#13;
        self.blobs_dict = dict((blob, list_of_points) for blob, list_of_points in self.blobs_dict.items() if len(list_of_points) &gt;= n)&#13;
&#13;
    def get_largest_blob_key(self):&#13;
        '''Finds the key of the largest blob.&#13;
&#13;
        Returns:&#13;
            int specifying the key of the largest blob with that color, or None if no such blob exists&#13;
        '''&#13;
        largest_blob_key = None&#13;
        values = self.blobs_dict.values()&#13;
        if len(values) &gt; 0:&#13;
            longest_points_list = functools.reduce(lambda largest, current: largest if (largest &gt; current) else current, values)&#13;
            sample_x, sample_y = longest_points_list[0]&#13;
            largest_blob_key = self.keys.at(sample_x, sample_y).value&#13;
            self.largest_blob_size = len(self.blobs_dict[largest_blob_key])&#13;
        return largest_blob_key&#13;
&#13;
    def get_blob_center(self):&#13;
        '''Approximates the coordinates of the center of the largest blob.&#13;
&#13;
        Returns:&#13;
            (int, int) specifying the center of the largest blob, &#13;
            or None if self.get_largest_blob_key() returns None&#13;
        '''&#13;
        blob_center = None&#13;
        largest_blob_key = self.get_largest_blob_key()&#13;
        if largest_blob_key:&#13;
            xs = []&#13;
            ys = []&#13;
            for (x, y) in self.blobs_dict[largest_blob_key]:&#13;
                xs.append(x)&#13;
                ys.append(y)&#13;
            average_x = float(sum(xs))/len(xs)&#13;
            average_y = float(sum(ys))/len(ys)&#13;
            blob_center = (int(average_x), int(average_y))&#13;
        return blob_center&#13;
&#13;
    def get_blob_size(self):&#13;
        '''Gets the number of pixels in the largest blob.&#13;
&#13;
        Returns:&#13;
            int: The size, in pixels, of the largest blob&#13;
        '''&#13;
        return self.largest_blob_size&#13;
&#13;
&#13;
class MyMatrix():&#13;
    '''A custom class to get dimensions, values, and neighboring values of the pixel_matrix.&#13;
&#13;
    Args:&#13;
        num_cols (int): the number of columns in the matrix, specified in ColorFinder as downsize_width&#13;
        num_rows (int): the number of rows in the matrix, specified in ColorFinder as downsize_height&#13;
    '''&#13;
    def __init__(self, num_cols, num_rows):&#13;
        self.num_cols = num_cols&#13;
        self.num_rows = num_rows&#13;
        self._matrix = [[MatrixValueContainer() for _ in range(self.num_rows)] for _ in range(self.num_cols)]&#13;
        self.size = self.num_cols * self.num_rows&#13;
&#13;
    def at(self, i, j):&#13;
        '''Gets the desired MatrixValueContainer object.&#13;
&#13;
        Args:&#13;
            i (int): the x-coordinate in self&#13;
            j (int): the y-coordinate in self&#13;
&#13;
        Returns:&#13;
            the MatrixValueContainer at the specified coordinates&#13;
        '''&#13;
        return self._matrix[i][j]&#13;
&#13;
    def fill_gaps(self):&#13;
        '''Fills in squares in self._matrix that meet the condition in the surrounded method.&#13;
&#13;
        Ignores the surrounding value if it is 'white' or 'black' to give preference to red, blue, green, and yellow.&#13;
        '''&#13;
        for i in range(self.num_cols):&#13;
            for j in range(self.num_rows):&#13;
                val = self.surrounded(i, j)&#13;
                if val != None and val != 'white' and val != 'black':&#13;
                    self.at(i, j).set(val)&#13;
&#13;
    def surrounded(self, i, j):&#13;
        '''Checks if a point is surrounded by at least 3 points of the same value.&#13;
&#13;
        Args:&#13;
            i (int): the x-coordinate in self._matrix&#13;
            j (int): the y-coordinate in self._matrix&#13;
&#13;
        Returns:&#13;
            the surrounding value if the condition is True, otherwise returns None&#13;
            When used in the context of ColorFinder, the surrounding value would be the string&#13;
            specifying the name of the color surrounding this square.&#13;
        '''&#13;
        if i != 0 and i != self.num_cols-1 and j != 0 and j != self.num_rows-1:&#13;
            left_value, up_value, right_value, down_value = self.get_neighboring_values(i, j)&#13;
            if left_value == up_value and left_value == right_value:&#13;
                return left_value&#13;
            if left_value == up_value and left_value == down_value:&#13;
                return left_value&#13;
            if left_value == right_value and left_value == down_value:&#13;
                return left_value&#13;
            if right_value == up_value and right_value == down_value:&#13;
                return right_value&#13;
        return None&#13;
&#13;
    def get_neighboring_values(self, i, j):&#13;
        '''Returns the values in the four surrounding MatrixValueContainers.&#13;
        &#13;
        Args:&#13;
            i (int): the x-coordinate in self._matrix&#13;
            j (int): the y-coordinate in self._matrix&#13;
&#13;
        Returns:&#13;
            A four-tuple containing (left_value, up_value, right_value, and down_value)&#13;
        '''&#13;
        return (self.at(i-1, j), self.at(i, j-1), self.at(i + 1, j), self.at(i, j + 1))&#13;
&#13;
&#13;
class MatrixValueContainer():&#13;
    '''Simple container for values in a MyMatrix object.&#13;
&#13;
    This class is intended to clean the syntax of setting&#13;
    a new value in the MyMatrix object.&#13;
&#13;
    So we replace this:&#13;
        matrix.get_value(i, j)&#13;
        matrix.set_value(i, j, new_value)&#13;
    with this:&#13;
        matrix.at(i, j).value&#13;
        matrix.at(i, j).set(new_value)&#13;
    '''&#13;
    def __init__(self):&#13;
        self.value = None&#13;
&#13;
    def set(self, new_value):&#13;
        self.value = new_value&#13;
&#13;
&#13;
async def cozmo_program(robot: cozmo.robot.Robot):&#13;
    color_finder = ColorFinder(robot)&#13;
    await color_finder.run()&#13;
&#13;
cozmo.robot.Robot.drive_off_charger_on_connect = True&#13;
cozmo.run_program(cozmo_program, use_viewer = True, force_viewer_on_top = True)&#13;
</script>
        <sys_created_by>Arnoud.Kooi</sys_created_by>
        <sys_created_on>2018-07-15 21:07:58</sys_created_on>
        <sys_id>6d79308a4f575f009881c5c18110c7b0</sys_id>
        <sys_mod_count>0</sys_mod_count>
        <sys_updated_by>Arnoud.Kooi</sys_updated_by>
        <sys_updated_on>2018-07-15 21:07:58</sys_updated_on>
        <test_parameters/>
    </x_snc_cozmo_guard_python_commands>
</record_update>
]]></payload>
        <sys_class_name>sys_metadata_link</sys_class_name>
        <sys_created_by>Arnoud.Kooi</sys_created_by>
        <sys_created_on>2019-03-05 21:13:43</sys_created_on>
        <sys_customer_update>false</sys_customer_update>
        <sys_id>a135704d4f8c33009881c5c18110c7e0</sys_id>
        <sys_mod_count>0</sys_mod_count>
        <sys_name>color_finder.py</sys_name>
        <sys_package display_value="Cozmo Guard" source="x_snc_cozmo_guard">2df0e27d4fdf1f009881c5c18110c780</sys_package>
        <sys_policy/>
        <sys_replace_on_upgrade>false</sys_replace_on_upgrade>
        <sys_scope display_value="Cozmo Guard">2df0e27d4fdf1f009881c5c18110c780</sys_scope>
        <sys_update_name>sys_metadata_link_a135704d4f8c33009881c5c18110c7e0</sys_update_name>
        <sys_updated_by>Arnoud.Kooi</sys_updated_by>
        <sys_updated_on>2019-03-05 21:13:43</sys_updated_on>
        <tablename>x_snc_cozmo_guard_python_commands</tablename>
    </sys_metadata_link>
</record_update>
