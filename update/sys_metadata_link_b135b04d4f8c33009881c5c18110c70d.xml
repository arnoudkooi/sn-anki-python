<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_metadata_link">
    <sys_metadata_link action="INSERT_OR_UPDATE">
        <directory>update</directory>
        <documentkey>eff209a64f9b9f0035e0fdb28110c70d</documentkey>
        <payload><![CDATA[<?xml version="1.0" encoding="UTF-8"?><record_update table="x_snc_cozmo_guard_python_commands">
    <x_snc_cozmo_guard_python_commands action="INSERT_OR_UPDATE">
        <active>false</active>
        <file_name>face.py</file_name>
        <name>face</name>
        <script>#!/usr/bin/env python3&#13;
&#13;
# Copyright (c) 2016 Anki, Inc.&#13;
#&#13;
# Licensed under the Apache License, Version 2.0 (the "License");&#13;
# you may not use this file except in compliance with the License.&#13;
# You may obtain a copy of the License in the file LICENSE.txt or at&#13;
#&#13;
#     http://www.apache.org/licenses/LICENSE-2.0&#13;
#&#13;
# Unless required by applicable law or agreed to in writing, software&#13;
# distributed under the License is distributed on an "AS IS" BASIS,&#13;
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#13;
# See the License for the specific language governing permissions and&#13;
# limitations under the License.&#13;
&#13;
'''Cozmo the Desk Security Guard.&#13;
&#13;
Cozmo patrols your desk, looks out for unknown faces, and reports them to you.&#13;
'''&#13;
&#13;
import asyncio&#13;
from random import randint&#13;
import sys&#13;
import time&#13;
&#13;
import cozmo&#13;
from cozmo.util import degrees, distance_mm, speed_mmps&#13;
&#13;
sys.path.append('../lib/')&#13;
import twitter_helpers as twitter_helpers&#13;
import cozmo_twitter_keys as twitter_keys&#13;
&#13;
&#13;
#: The twitter user (without the @ symbol) that will receive security photos, etc.&#13;
OWNER_TWITTER_USERNAME = ""&#13;
&#13;
#: The name that the owner's face is enrolled as (i.e. your username in the app)&#13;
#: When that face is seen, Cozmo will assume no other faces currently seen are intruders&#13;
OWNER_FACE_ENROLL_NAME = ""&#13;
&#13;
&#13;
if OWNER_TWITTER_USERNAME == "":&#13;
    sys.exit("You must fill in OWNER_TWITTER_USERNAME")&#13;
if OWNER_FACE_ENROLL_NAME == "":&#13;
    sys.exit("You must fill in OWNER_FACE_ENROLL_NAME")&#13;
&#13;
&#13;
class TwitterStreamToAppCommunication:&#13;
    '''Class for messaging to/from SecurityGuardStreamListener&#13;
&#13;
    Tweepy doesn't support asyncio, so this program must run the SecurityGuardStreamListener&#13;
    stream in its own thread. Communication is deliberately limited between the rest of the&#13;
    program and the stream to some simple signalling bools to avoid running&#13;
    into any threading issues like race conditions.&#13;
    '''&#13;
    def __init__(self):&#13;
        self.is_armed = True&#13;
        self.has_arm_request = False&#13;
        self.has_disarm_request = False&#13;
&#13;
&#13;
class SecurityGuardStreamListener(twitter_helpers.CozmoTweetStreamListener):&#13;
    '''React to Tweets sent to the Cozmo user, live, as they happen...&#13;
&#13;
    on_tweet_from_user is called whenever the Twitter user receives a tweet.&#13;
    This allows the only the owner to enable and disable the alarm via Twitter.&#13;
    '''&#13;
&#13;
    def __init__(self, twitter_api, stream_to_app_comms):&#13;
        super().__init__(None, twitter_api)&#13;
        self.stream_to_app_comms = stream_to_app_comms&#13;
        self.owner_username = OWNER_TWITTER_USERNAME&#13;
&#13;
    def do_arm(self):&#13;
        '''Request security guard alerts be enabled'''&#13;
        if self.stream_to_app_comms.is_armed:&#13;
            return "Already Armed!"&#13;
        else:&#13;
            self.stream_to_app_comms.has_arm_request = True&#13;
            return "Arming!"&#13;
&#13;
    def do_disarm(self):&#13;
        '''Request security guard alerts be disabled'''&#13;
        if self.stream_to_app_comms.is_armed:&#13;
            self.stream_to_app_comms.has_disarm_request = True&#13;
            return "Disarming!"&#13;
        else:&#13;
            return "Already Disarmed!"&#13;
&#13;
    def get_supported_commands(self):&#13;
        '''Construct a list of all methods in this class that start with "do_" - these are commands we accept.'''&#13;
        prefix_str = "do_"&#13;
        prefix_len = len(prefix_str)&#13;
        supported_commands = []&#13;
        for func_name in dir(self.__class__):&#13;
            if func_name.startswith(prefix_str):&#13;
                supported_commands.append(func_name[prefix_len:])&#13;
        return supported_commands&#13;
&#13;
    def get_command(self, command_name):&#13;
        '''Find a matching "do_" function and return it. Return None if there's no match.'''&#13;
        try:&#13;
            return getattr(self, 'do_' + command_name.lower())&#13;
        except AttributeError:&#13;
            return None&#13;
&#13;
    def extract_command_from_string(self, in_string):&#13;
        '''Separate inString at each space, loop through until we find a command, and return tuple of cmd_func and cmd_args.'''&#13;
&#13;
        split_string = in_string.split()&#13;
&#13;
        for i in range(len(split_string)):&#13;
&#13;
            cmd_func = self.get_command(split_string[i])&#13;
&#13;
            if cmd_func:&#13;
                return cmd_func&#13;
&#13;
        # No valid command found&#13;
        return None&#13;
&#13;
    def on_tweet_from_user(self, json_data, tweet_text, from_user, is_retweet):&#13;
        '''Handle every new tweet as it appears.'''&#13;
&#13;
        # ignore retweets&#13;
        if is_retweet:&#13;
            return True&#13;
&#13;
        # ignore any replies from this account (otherwise it would infinite loop as soon as you reply)&#13;
        # allow other messages from this account (so you can tweet at yourself to control Cozmo if you want)&#13;
&#13;
        user_me = self.twitter_api.me()&#13;
        is_from_me = (from_user.get('id') == user_me.id)&#13;
&#13;
        if is_from_me and tweet_text.startswith("@"):&#13;
            # ignore replies from this account&#13;
            return&#13;
&#13;
        from_user_name = from_user.get('screen_name')&#13;
&#13;
        from_owner = from_user_name.lower() == self.owner_username.lower()&#13;
        if not from_owner:&#13;
            print("Ignoring tweet from non-owner user %s" % from_user_name)&#13;
            return&#13;
&#13;
        tweet_id = json_data.get('id_str')&#13;
&#13;
        cmd_func = self.extract_command_from_string(tweet_text)&#13;
&#13;
        reply_prefix = "@" + from_user_name + " "&#13;
        if cmd_func is not None:&#13;
            result_string = cmd_func()&#13;
            if result_string:&#13;
                self.post_tweet(reply_prefix + result_string, tweet_id)&#13;
        else:&#13;
            self.post_tweet(reply_prefix + "Sorry, I don't understand; available commands are: "&#13;
                            + str(self.get_supported_commands()), tweet_id)&#13;
&#13;
&#13;
class DeskSecurityGuard:&#13;
    '''Container for Security Guard status'''&#13;
&#13;
    def __init__(self, twitter_api):&#13;
        self.twitter_api = twitter_api&#13;
        self.owner_username = OWNER_TWITTER_USERNAME&#13;
        self.owner_name = OWNER_FACE_ENROLL_NAME&#13;
&#13;
        self.is_armed = True&#13;
&#13;
        self.time_first_observed_intruder = None&#13;
        self.time_last_observed_intruder = None&#13;
&#13;
        self.time_first_observed_owner = None&#13;
        self.time_last_observed_owner = None&#13;
&#13;
        self.time_last_suspicious = None&#13;
        self.time_last_uploaded_photo = None&#13;
        self.time_last_announced_intruder = None&#13;
        self.time_last_pounced_at_intruder = None&#13;
        self.time_last_announced_owner = None&#13;
&#13;
    def is_investigating_intruder(self):&#13;
        '''Has an unknown face recently been seen?'''&#13;
        return self.time_first_observed_intruder is not None&#13;
&#13;
    def has_confirmed_intruder(self):&#13;
        '''The robot has seen an intruder for long enough that it's pretty sure it's not the owner.'''&#13;
        if self.time_first_observed_intruder:&#13;
            elapsed_time = time.time() - self.time_first_observed_intruder&#13;
            return elapsed_time &gt; 2.0&#13;
        return False&#13;
&#13;
&#13;
def did_occur_recently(event_time, max_elapsed_time):&#13;
    '''Did event_time occur and was it within the last max_elapsed_time seconds?'''&#13;
    if event_time is None:&#13;
        return False&#13;
    elapsed_time = time.time() - event_time&#13;
    return elapsed_time &lt; max_elapsed_time&#13;
&#13;
&#13;
async def check_for_intruder(robot, dsg:DeskSecurityGuard):&#13;
    ''''''&#13;
&#13;
    # Check which faces can be seen, and if any are the owner or an intruder&#13;
&#13;
    owner_face = None&#13;
    intruder_face = None&#13;
    for visible_face in robot.world.visible_faces:&#13;
        if visible_face.name == dsg.owner_name:&#13;
            if owner_face:&#13;
                print("Multiple faces with name %s seen - %s and %s!" %&#13;
                      (dsg.owner_name, owner_face, visible_face))&#13;
            owner_face = visible_face&#13;
        else:&#13;
            # just use the first intruder seen&#13;
            if not intruder_face:&#13;
                intruder_face = visible_face&#13;
&#13;
    # Update times first/last seen owner or an intruder&#13;
&#13;
    if owner_face:&#13;
        dsg.time_last_observed_owner = owner_face.last_observed_time&#13;
        if dsg.time_first_observed_owner is None:&#13;
            dsg.time_first_observed_owner = dsg.time_last_observed_owner&#13;
&#13;
    if intruder_face:&#13;
        if dsg.time_last_observed_intruder is None or \&#13;
                        intruder_face.last_observed_time &gt; dsg.time_last_observed_intruder:&#13;
            dsg.time_last_observed_intruder = intruder_face.last_observed_time&#13;
&#13;
        if dsg.time_first_observed_intruder is None:&#13;
            dsg.time_first_observed_intruder = dsg.time_last_observed_intruder&#13;
&#13;
    # Check if there's anything to investigate&#13;
&#13;
    can_see_owner = did_occur_recently(dsg.time_last_observed_owner, 1.0)&#13;
    can_see_intruders = did_occur_recently(dsg.time_last_observed_intruder, 1.0)&#13;
    if not dsg.is_armed:&#13;
        can_see_intruders = False&#13;
    if not can_see_intruders:&#13;
        dsg.time_first_observed_intruder = None&#13;
&#13;
    if can_see_owner:&#13;
&#13;
        # If robot can see the owner then look at and greet them occasionally&#13;
&#13;
        robot.set_all_backpack_lights(cozmo.lights.green_light)&#13;
        if not did_occur_recently(dsg.time_last_announced_owner, 60.0):&#13;
            await robot.play_anim_trigger(cozmo.anim.Triggers.NamedFaceInitialGreeting).wait_for_completed()&#13;
            dsg.time_last_announced_owner = time.time()&#13;
        else:&#13;
            await robot.turn_towards_face(owner_face).wait_for_completed()&#13;
    elif can_see_intruders:&#13;
&#13;
        # Don't react unless this is a confirmed intruder&#13;
&#13;
        is_confirmed_intruder = dsg.has_confirmed_intruder()&#13;
        if is_confirmed_intruder:&#13;
            # Definitely an intruder - turn backpack red to indicate&#13;
            robot.set_all_backpack_lights(cozmo.lights.red_light)&#13;
&#13;
            # Tweet a photo (every X seconds)&#13;
            if not did_occur_recently(dsg.time_last_uploaded_photo, 15.0):&#13;
                # Tweet the image to the owner&#13;
                latest_image = robot.world.latest_image&#13;
                if latest_image is not None:&#13;
                    status_text = "@" + dsg.owner_username + " Intruder Detected"&#13;
                    media_ids = twitter_helpers.upload_images(dsg.twitter_api, [latest_image.raw_image])&#13;
                    posted_image = twitter_helpers.post_tweet(dsg.twitter_api, status_text, media_ids=media_ids)&#13;
                    if posted_image:&#13;
                        dsg.time_last_uploaded_photo = time.time()&#13;
                    else:&#13;
                        print("Failed to tweet photo of intruder!")&#13;
                else:&#13;
                    print("No camera image available to tweet!")&#13;
&#13;
            # Sound an alarm (every X seconds)&#13;
            if not did_occur_recently(dsg.time_last_announced_intruder, 10):&#13;
                await robot.say_text("Intruder Alert").wait_for_completed()&#13;
                dsg.time_last_announced_intruder = time.time()&#13;
&#13;
            # Pounce at intruder (every X seconds)&#13;
            if not did_occur_recently(dsg.time_last_pounced_at_intruder, 10.0):&#13;
                await robot.play_anim_trigger(cozmo.anim.Triggers.CubePouncePounceNormal).wait_for_completed()&#13;
                dsg.time_last_pounced_at_intruder = time.time()&#13;
&#13;
            # Turn towards the intruder to keep them in view&#13;
            await robot.turn_towards_face(intruder_face).wait_for_completed()&#13;
        else:&#13;
            # Possibly an intruder - turn backpack blue to indicate, and play&#13;
            # suspicious animation (if not played recently)&#13;
&#13;
            robot.set_all_backpack_lights(cozmo.lights.blue_light)&#13;
            if not did_occur_recently(dsg.time_last_suspicious, 10.0):&#13;
                await robot.play_anim_trigger(cozmo.anim.Triggers.HikingInterestingEdgeThought).wait_for_completed()&#13;
                dsg.time_last_suspicious = time.time()&#13;
            else:&#13;
                # turn robot towards intruder face slightly to get a better look at them&#13;
                await robot.turn_towards_face(intruder_face).wait_for_completed()&#13;
    else:&#13;
        robot.set_backpack_lights_off()&#13;
&#13;
&#13;
async def desk_security_guard(robot):&#13;
    '''The core of the desk_security_guard program'''&#13;
&#13;
    # Turn on image receiving by the camera&#13;
    robot.camera.image_stream_enabled = True&#13;
&#13;
    # Connect Twitter, run async in the background&#13;
    twitter_api, twitter_auth = twitter_helpers.init_twitter(twitter_keys)&#13;
    stream_to_app_comms = TwitterStreamToAppCommunication()&#13;
    stream_listener = SecurityGuardStreamListener(twitter_api, stream_to_app_comms)&#13;
    twitter_stream = twitter_helpers.CozmoStream(twitter_auth, stream_listener)&#13;
    twitter_stream.async_userstream(_with='user')&#13;
&#13;
    # Create our security guard&#13;
    dsg = DeskSecurityGuard(twitter_api)&#13;
&#13;
    # Make sure Cozmo is clear of the charger&#13;
    if robot.is_on_charger:&#13;
        # Drive fully clear of charger (not just off the contacts)&#13;
        await robot.drive_off_charger_contacts().wait_for_completed()&#13;
        await robot.drive_straight(distance_mm(150), speed_mmps(50)).wait_for_completed()&#13;
&#13;
    # Tilt head up to look for people&#13;
    await robot.set_head_angle(cozmo.robot.MAX_HEAD_ANGLE).wait_for_completed()&#13;
&#13;
    initial_pose_angle = robot.pose_angle&#13;
&#13;
    patrol_offset = 0  # middle&#13;
    max_pose_angle = 45  # offset from initial pose_angle (up to +45 or -45 from this)&#13;
&#13;
    # Time to wait between each turn and patrol, in seconds&#13;
    time_between_turns = 2.5&#13;
    time_between_patrols = 20&#13;
&#13;
    time_for_next_turn = time.time() + time_between_turns&#13;
    time_for_next_patrol = time.time() + time_between_patrols&#13;
&#13;
    while True:&#13;
&#13;
        # Handle any external requests to arm or disarm Cozmo&#13;
        if stream_to_app_comms.has_arm_request:&#13;
            stream_to_app_comms.has_arm_request = False&#13;
            if not dsg.is_armed:&#13;
                print("Alarm Armed")&#13;
                dsg.is_armed = True&#13;
        if stream_to_app_comms.has_disarm_request:&#13;
            stream_to_app_comms.has_disarm_request = False&#13;
            if dsg.is_armed:&#13;
                print("Alarm Disarmed")&#13;
                dsg.is_armed = False&#13;
&#13;
        stream_to_app_comms.is_armed = dsg.is_armed&#13;
&#13;
        # Turn head every few seconds to cover a wider field of view&#13;
        # Only do this if not currently investigating an intruder&#13;
&#13;
        if (time.time() &gt; time_for_next_turn) and not dsg.is_investigating_intruder():&#13;
            # pick a random amount to turn&#13;
            angle_to_turn = randint(10,40)&#13;
&#13;
            # 50% chance of turning in either direction&#13;
            if randint(0,1) &gt; 0:&#13;
                angle_to_turn = -angle_to_turn&#13;
&#13;
            # Clamp the amount to turn&#13;
&#13;
            face_angle = (robot.pose_angle - initial_pose_angle).degrees&#13;
&#13;
            face_angle += angle_to_turn&#13;
            if face_angle &gt; max_pose_angle:&#13;
                angle_to_turn -= (face_angle - max_pose_angle)&#13;
            elif face_angle &lt; -max_pose_angle:&#13;
                angle_to_turn -= (face_angle + max_pose_angle)&#13;
&#13;
            # Turn left/right&#13;
            await robot.turn_in_place(degrees(angle_to_turn)).wait_for_completed()&#13;
&#13;
            # Tilt head up/down slightly&#13;
            await robot.set_head_angle(degrees(randint(30,44))).wait_for_completed()&#13;
&#13;
            # Queue up the next time to look around&#13;
            time_for_next_turn = time.time() + time_between_turns&#13;
&#13;
        # Every now and again patrol left and right between 3 patrol points&#13;
&#13;
        if (time.time() &gt; time_for_next_patrol) and not dsg.is_investigating_intruder():&#13;
&#13;
            # Check which way robot is facing vs initial pose, pick a new patrol point&#13;
&#13;
            face_angle = (robot.pose_angle - initial_pose_angle).degrees&#13;
            drive_right = (patrol_offset &lt; 0) or ((patrol_offset == 0) and (face_angle &gt; 0))&#13;
&#13;
            # Turn to face the new patrol point&#13;
&#13;
            if drive_right:&#13;
                await robot.turn_in_place(degrees(90 - face_angle)).wait_for_completed()&#13;
                patrol_offset += 1&#13;
            else:&#13;
                await robot.turn_in_place(degrees(-90 - face_angle)).wait_for_completed()&#13;
                patrol_offset -= 1&#13;
&#13;
            # Drive to the patrol point, playing animations along the way&#13;
&#13;
            await robot.drive_wheels(20, 20)&#13;
            for i in range(1,4):&#13;
                await robot.play_anim("anim_hiking_driving_loop_0" + str(i)).wait_for_completed()&#13;
&#13;
            # Stop driving&#13;
&#13;
            robot.stop_all_motors()&#13;
&#13;
            # Turn to face forwards again&#13;
&#13;
            face_angle = (robot.pose_angle - initial_pose_angle).degrees&#13;
            if face_angle &gt; 0:&#13;
                await robot.turn_in_place(degrees(-90)).wait_for_completed()&#13;
            else:&#13;
                await robot.turn_in_place(degrees(90)).wait_for_completed()&#13;
&#13;
            # Queue up the next time to patrol&#13;
            time_for_next_patrol = time.time() + time_between_patrols&#13;
&#13;
        # look for intruders&#13;
&#13;
        await check_for_intruder(robot, dsg)&#13;
&#13;
        # Sleep to allow other things to run&#13;
&#13;
        await asyncio.sleep(0.05)&#13;
&#13;
&#13;
async def run(sdk_conn):&#13;
    '''The run method runs once the Cozmo SDK is connected.'''&#13;
    robot = await sdk_conn.wait_for_robot()&#13;
&#13;
    try:&#13;
        await desk_security_guard(robot)&#13;
&#13;
    except KeyboardInterrupt:&#13;
        print("")&#13;
        print("Exit requested by user")&#13;
&#13;
&#13;
if __name__ == '__main__':&#13;
    cozmo.setup_basic_logging()&#13;
    cozmo.robot.Robot.drive_off_charger_on_connect = False  # Stay on charger until init&#13;
    try:&#13;
        cozmo.connect_with_tkviewer(run, force_on_top=True)&#13;
    except cozmo.ConnectionError as e:&#13;
        sys.exit("A connection error occurred: %s" % e)&#13;
&#13;
</script>
        <sys_created_by>Arnoud.Kooi</sys_created_by>
        <sys_created_on>2018-07-17 11:06:40</sys_created_on>
        <sys_id>eff209a64f9b9f0035e0fdb28110c70d</sys_id>
        <sys_mod_count>1</sys_mod_count>
        <sys_updated_by>Arnoud.Kooi</sys_updated_by>
        <sys_updated_on>2018-07-17 11:25:17</sys_updated_on>
        <test_parameters/>
    </x_snc_cozmo_guard_python_commands>
</record_update>
]]></payload>
        <sys_class_name>sys_metadata_link</sys_class_name>
        <sys_created_by>Arnoud.Kooi</sys_created_by>
        <sys_created_on>2019-03-05 21:13:44</sys_created_on>
        <sys_customer_update>false</sys_customer_update>
        <sys_id>b135b04d4f8c33009881c5c18110c70d</sys_id>
        <sys_mod_count>0</sys_mod_count>
        <sys_name>face.py</sys_name>
        <sys_package display_value="Cozmo Guard" source="x_snc_cozmo_guard">2df0e27d4fdf1f009881c5c18110c780</sys_package>
        <sys_policy/>
        <sys_replace_on_upgrade>false</sys_replace_on_upgrade>
        <sys_scope display_value="Cozmo Guard">2df0e27d4fdf1f009881c5c18110c780</sys_scope>
        <sys_update_name>sys_metadata_link_b135b04d4f8c33009881c5c18110c70d</sys_update_name>
        <sys_updated_by>Arnoud.Kooi</sys_updated_by>
        <sys_updated_on>2019-03-05 21:13:44</sys_updated_on>
        <tablename>x_snc_cozmo_guard_python_commands</tablename>
    </sys_metadata_link>
</record_update>
